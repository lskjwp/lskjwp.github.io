<!DOCTYPE HTML>
<html lang="zh-CN">



<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta name="baidu-site-verification" content="code-p6MPyNrcYn">
    <meta charset="utf-8">
    <meta name="keywords" content="Golang学习笔记, HTML,CSS,JavaScript,JQuery,Java,Vue,学习笔记,生活随笔">
    <meta name="description" content="关闭一扇窗，另一扇等着你打开！往事如烟，浅笑而安。">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Golang学习笔记 | lskj</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>
<style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loader页面消失采用渐隐的方式*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }
    
    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }
    
   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}
    
    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}
    
   
    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo出现动画 */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()
 </script>
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="lskj" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loader页面消失采用渐隐的方式*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }
    
    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }
    
   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}
    
    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}
    
   
    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo出现动画 */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()
 </script>
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>





 <div id="loading-container">
     <p class="loading-text">玩命加载中 . . . </p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><!--动态背景-->
    <!-- <div id="bg"><canvas></canvas><canvas></canvas><canvas></canvas></div>
    <script src="/js/canva_moving_effect.js"></script> -->

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">lskj</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/galleries" class="waves-effect waves-light">
      
      <i class="fas fa-image" style="zoom: 0.6;"></i>
      
      <span>相册</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/navigate" class="waves-effect waves-light">
      
      <i class="fas fa-location-arrow" style="zoom: 0.6;"></i>
      
      <span>导航</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <!--全屏-->
  <li id="fullscreen_li" class="fullscreen"><a href="javascript:void(0);" class="modal-trigger waves-effect waves-light"><i id="fullscreen" class="fas fa-expand-arrows-alt" title="全屏" style="zoom: 0.65;"></i></a></li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">lskj</div>
        <div class="logo-desc">
            
            关闭一扇窗，另一扇等着你打开！往事如烟，浅笑而安。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/galleries" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-image"></i>
			
			相册
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/navigate" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-location-arrow"></i>
			
			导航
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<!-- <div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/lskjwp/image/imageCover/Go学习笔记.jpg')"> -->
    <div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Golang学习笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
        background-color: rgb(255, 255, 255,0.7);
        border-radius: 10px;
        box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        background: linear-gradient(to bottom right,#61B5F3 0%, #26D6D1 100%);
        width: 35px;
        height: 35px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 35px;
        position: absolute;
        right: 0px;
        /* font-size: 1.4rem; */
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Go/">
                                <span class="chip bg-color">Go</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Go/" class="post-category">
                                Go
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:
                    2021-06-17
                </div>
                

                

                <!--添加作者信息--> 
                <div class="info-break-policy"> 
                     
                        <i class="fa fa-pencil"></i> 作者: 勇也很努力
                     
                </div>

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:
                    25.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:
                    96 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>学习文档链接：<a href="http://c.biancheng.net/golang/" target="_blank" rel="noopener">Go入门学习</a></p>
<a id="more"></a>

<h1 id="一、环境安装"><a href="#一、环境安装" class="headerlink" title="一、环境安装"></a>一、环境安装</h1><p>Go官网下载地址：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a></p>
<p>Go官方镜像站：<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a></p>
<p>Windows下运行下载好的可执行文件即可完成安装。</p>
<h2 id="1、GOROOT和GOPATH"><a href="#1、GOROOT和GOPATH" class="headerlink" title="1、GOROOT和GOPATH"></a>1、GOROOT和GOPATH</h2><p><code>GOROOT</code>和<code>GOPATH</code>都是环境变量，其中<code>GOROOT</code>是安装go开发包的路径，而从Go 1.8版本开始，Go开发包在安装完成后会为<code>GOPATH</code>设置一个默认目录，并且在Go1.14及之后的版本中启用了Go Module模式之后，不一定非要将代码写到GOPATH目录下，所以也就<strong>不需要自己配置GOPATH</strong>了，使用默认的即可。</p>
<h2 id="2、GOPROXY"><a href="#2、GOPROXY" class="headerlink" title="2、GOPROXY"></a>2、GOPROXY</h2><p>Go1.14版本之后，都推荐使用<code>go mod</code>模式来管理依赖环境了，也不再强制把代码必须写在<code>GOPATH</code>下面的src目录。</p>
<p>默认的配置：</p>
<pre class=" language-bash"><code class="language-bash">GOPROXY<span class="token operator">=</span>https://proxy.golang.org,direct</code></pre>
<p>修改GOPROXY：</p>
<pre class=" language-bash"><code class="language-bash">go <span class="token function">env</span> -w GOPROXY<span class="token operator">=</span>https://goproxy.cn,direct</code></pre>
<h2 id="3、命令"><a href="#3、命令" class="headerlink" title="3、命令"></a>3、命令</h2><ul>
<li><p><code>go env</code>用于打印Go语言的环境信息。</p>
</li>
<li><p><code>go run</code>命令可以编译并运行命令源码文件。</p>
</li>
<li><p><code>go get</code>可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。</p>
</li>
<li><p><code>go build</code>命令用于编译我们指定的源码文件或代码包以及它们的依赖包。</p>
</li>
<li><p><code>go install</code>用于编译并安装指定的代码包及它们的依赖包。</p>
</li>
<li><p><code>go clean</code>命令会删除掉执行其它命令时产生的一些文件和目录。</p>
</li>
<li><p><code>go doc</code>命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。</p>
</li>
<li><p><code>go test</code>命令用于对Go语言编写的程序进行测试。</p>
</li>
<li><p><code>go list</code>命令的作用是列出指定的代码包的信息。</p>
</li>
<li><p><code>go fix</code>会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。</p>
</li>
<li><p><code>go vet</code>是一个用于检查Go语言源码中静态错误的简单工具。</p>
</li>
<li><p><code>go tool pprof</code>命令来交互式的访问概要文件的内容。</p>
</li>
</ul>
<h1 id="二、Hello-Go"><a href="#二、Hello-Go" class="headerlink" title="二、Hello Go"></a>二、Hello Go</h1><p><strong>1、创建一个名为hello的文件夹</strong>；</p>
<p><strong>2、进入命令行，对项目进行初始化</strong>；</p>
<p>使用go module模式新建项目时，通过<code>go mod init 项目名</code>命令对项目进行初始化，该命令会在项目的根目录下生成<code>go.mod</code>文件。</p>
<pre class=" language-bash"><code class="language-bash">go mod init hello</code></pre>
<p><strong>3、在hello目录下新建main.go文件</strong>；</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main <span class="token comment" spellcheck="true">//声明main包，表明当前是一个可执行程序</span>

<span class="token keyword">import</span> <span class="token string">"fmt"</span> <span class="token comment" spellcheck="true">//导入内置fmt包</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//main函数，是程序执行的入口</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Go"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//在终端打印Hello Go</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>4、编译</strong>；</p>
<p>在hello目录下的命令行中执行以下命令：</p>
<pre class=" language-bash"><code class="language-bash">go build</code></pre>
<p><code>go build</code>：表示将源代码编译成可执行文件。</p>
<pre class=" language-bash"><code class="language-bash">go build hello</code></pre>
<p>上述这种写法go编译器会去<code>GOPATH</code>的src目录下查找需要编译的<code>hello</code>项目。</p>
<p>编译得到的可执行文件保存在执行编译命令的当前目录下。可以通过<code>- o</code>参数指定编译后得到的可执行文件的名字。</p>
<pre class=" language-bash"><code class="language-bash">go build -o first.exe</code></pre>
<blockquote>
<p>go run</p>
</blockquote>
<p><code>go run main.go</code>也可以执行程序，该命令本质上也是先编译后执行。</p>
<blockquote>
<p>go install</p>
</blockquote>
<p><code>go install</code>表示安装的意思，它先编译源代码得到可执行文件，然后将可执行文件移动到<code>GOPATH</code>的bin目录下。因为境变量中配置了<code>GOPATH</code>下的bin目录，所以可以在任意地方直接执行可执行文件。</p>
<blockquote>
<p>跨平台编译</p>
</blockquote>
<p>默认<code>go build</code>的可执行文件都是当前操作系统可执行的文件，Go语言支持跨平台编译——在当前平台（例如Windows）下编译其他平台（例如Linux）的可执行文件。</p>
<h1 id="三、go-module"><a href="#三、go-module" class="headerlink" title="三、go module"></a>三、go module</h1><p><code>go module</code>是Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，<code>go module</code>将是Go语言默认的依赖管理工具。</p>
<h2 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h2><p>要启用<code>go module</code>支持首先要设置环境变量<code>GO111MODULE</code>，通过它可以开启或关闭模块支持，它有三个可选值：<code>off</code>、<code>on</code>、<code>auto</code>，默认值是<code>auto</code>。</p>
<ol>
<li><code>GO111MODULE=off</code>禁用模块支持，编译时会从<code>GOPATH</code>和<code>vendor</code>文件夹中查找包。</li>
<li><code>GO111MODULE=on</code>启用模块支持，编译时会忽略<code>GOPATH</code>和<code>vendor</code>文件夹，只根据 <code>go.mod</code>下载依赖。</li>
<li><code>GO111MODULE=auto</code>，当项目在<code>$GOPATH/src</code>外且项目根目录有<code>go.mod</code>文件时，开启模块支持。</li>
</ol>
<p>简单来说，设置<code>GO111MODULE=on</code>之后就可以使用<code>go module</code>了，以后就没有必要在GOPATH中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。</p>
<p>使用 go module 管理依赖后会在项目根目录下生成两个文件<code>go.mod</code>和<code>go.sum</code>。</p>
<h2 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h2><p>Go1.11之后设置GOPROXY命令为：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">export</span> GOPROXY<span class="token operator">=</span>https://goproxy.cn</code></pre>
<p>Go1.13之后<code>GOPROXY</code>默认值为<code>https://proxy.golang.org</code>。</p>
<pre class=" language-bash"><code class="language-bash">go <span class="token function">env</span> -w GOPROXY<span class="token operator">=</span>https://goproxy.cn,direct</code></pre>
<h2 id="go-mod命令"><a href="#go-mod命令" class="headerlink" title="go mod命令"></a>go mod命令</h2><p>常用的<code>go mod</code>命令如下：</p>
<pre><code>go mod download    下载依赖的module到本地cache（默认为$GOPATH/pkg/mod目录）
go mod edit        编辑go.mod文件
go mod graph       打印模块依赖图
go mod init        初始化当前文件夹, 创建go.mod文件
go mod tidy        增加缺少的module，删除无用的module
go mod vendor      将依赖复制到vendor下
go mod verify      校验依赖
go mod why         解释为什么需要依赖</code></pre><h2 id="go-mod文件"><a href="#go-mod文件" class="headerlink" title="go.mod文件"></a>go.mod文件</h2><p>go.mod文件记录了项目所有的依赖信息，其结构大致如下：</p>
<pre class=" language-sh"><code class="language-sh">module github.com/Q1mi/studygo/blogger

go 1.16

require (
    github.com/DeanThompson/ginpprof v0.0.0-20190408063150-3be636683586
    github.com/gin-gonic/gin v1.4.0
    github.com/go-sql-driver/mysql v1.4.1
    github.com/jmoiron/sqlx v1.2.0
    github.com/satori/go.uuid v1.2.0
    google.golang.org/appengine v1.6.1 // indirect
)</code></pre>
<p>其中，</p>
<ul>
<li><code>module</code>用来定义包名</li>
<li><code>require</code>用来定义依赖包及版本</li>
<li><code>indirect</code>表示间接引用</li>
</ul>
<p>依赖的版本</p>
<p>go mod支持语义化版本号，比如<code>go get foo@v1.2.3</code>，也可以跟git的分支或tag，比如<code>go get foo@master</code>，当然也可以跟git提交哈希，比如<code>go get foo@e3702bed2</code>。关于依赖的版本支持以下几种格式：</p>
<pre class=" language-go"><code class="language-go">gopkg<span class="token punctuation">.</span>in<span class="token operator">/</span>tomb<span class="token punctuation">.</span>v1 v1<span class="token number">.0</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">20141024135613</span><span class="token operator">-</span>dd632973f1e7
gopkg<span class="token punctuation">.</span>in<span class="token operator">/</span>vmihailenco<span class="token operator">/</span>msgpack<span class="token punctuation">.</span>v2 v2<span class="token number">.9</span><span class="token punctuation">.</span><span class="token number">1</span>
gopkg<span class="token punctuation">.</span>in<span class="token operator">/</span>yaml<span class="token punctuation">.</span>v2 <span class="token operator">&lt;=</span>v2<span class="token number">.2</span><span class="token punctuation">.</span><span class="token number">1</span>
github<span class="token punctuation">.</span>com<span class="token operator">/</span>tatsushid<span class="token operator">/</span><span class="token keyword">go</span><span class="token operator">-</span>fastping v0<span class="token number">.0</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">20160109021039</span><span class="token operator">-</span>d7bb493dee3e
latest</code></pre>
<h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p>在国内访问golang.org/x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库。</p>
<pre class=" language-go"><code class="language-go"><span class="token function">replace</span> <span class="token punctuation">(</span>
    golang<span class="token punctuation">.</span>org<span class="token operator">/</span>x<span class="token operator">/</span>crypto v0<span class="token number">.0</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">20180820150726</span><span class="token operator">-</span>614d502a4dac <span class="token operator">=</span><span class="token operator">></span> github<span class="token punctuation">.</span>com<span class="token operator">/</span>golang<span class="token operator">/</span>crypto v0<span class="token number">.0</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">20180820150726</span><span class="token operator">-</span>614d502a4dac
    golang<span class="token punctuation">.</span>org<span class="token operator">/</span>x<span class="token operator">/</span>net v0<span class="token number">.0</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">20180821023952</span><span class="token operator">-</span>922f4815f713 <span class="token operator">=</span><span class="token operator">></span> github<span class="token punctuation">.</span>com<span class="token operator">/</span>golang<span class="token operator">/</span>net v0<span class="token number">.0</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">20180826012351</span><span class="token operator">-</span>8a410e7b638d
    golang<span class="token punctuation">.</span>org<span class="token operator">/</span>x<span class="token operator">/</span>text v0<span class="token number">.3</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">=</span><span class="token operator">></span> github<span class="token punctuation">.</span>com<span class="token operator">/</span>golang<span class="token operator">/</span>text v0<span class="token number">.3</span><span class="token punctuation">.</span><span class="token number">0</span>
<span class="token punctuation">)</span></code></pre>
<h2 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h2><p>在项目中执行<code>go get</code>命令可以下载依赖包，并且还可以指定下载的版本。</p>
<ol>
<li>运行<code>go get -u</code>将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li>
<li>运行<code>go get -u=patch</code>将会升级到最新的修订版本</li>
<li>运行<code>go get package@version</code>将会升级到指定的版本号version</li>
</ol>
<p>如果下载所有依赖可以使用<code>go mod download</code>命令。</p>
<h2 id="整理依赖"><a href="#整理依赖" class="headerlink" title="整理依赖"></a>整理依赖</h2><p>在代码中删除依赖代码后，相关的依赖库并不会在<code>go.mod</code>文件中自动移除。这种情况下可以使用<code>go mod tidy</code>命令更新<code>go.mod</code>中的依赖关系。</p>
<h2 id="go-mod-edit"><a href="#go-mod-edit" class="headerlink" title="go mod edit"></a>go mod edit</h2><blockquote>
<p>格式化</p>
</blockquote>
<p>因为可以手动修改go.mod文件，所以有些时候需要格式化该文件。Go提供了一下命令：</p>
<pre class=" language-bash"><code class="language-bash">go mod edit -fmt</code></pre>
<blockquote>
<p>添加依赖项</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash">go mod edit -require<span class="token operator">=</span>golang.org/x/text</code></pre>
<blockquote>
<p>移除依赖项</p>
</blockquote>
<p>如果只是想修改<code>go.mod</code>文件中的内容，那么可以运行<code>go mod edit -droprequire=package path</code>，比如要在<code>go.mod</code>中移除<code>golang.org/x/text</code>包，可以使用如下命令：</p>
<pre class=" language-bash"><code class="language-bash">go mod edit -droprequire<span class="token operator">=</span>golang.org/x/text</code></pre>
<p>关于<code>go mod edit</code>的更多用法可以通过<code>go help mod edit</code>查看。</p>
<h2 id="项目中使用go-module"><a href="#项目中使用go-module" class="headerlink" title="项目中使用go module"></a>项目中使用go module</h2><blockquote>
<p>已有项目</p>
</blockquote>
<p>如果需要对一个已经存在的项目启用<code>go module</code>，可以按照以下步骤操作：</p>
<ol>
<li>在项目目录下执行<code>go mod init</code>，生成一个<code>go.mod</code>文件。</li>
<li>执行<code>go get</code>，查找并记录当前项目的依赖，同时生成一个<code>go.sum</code>记录每个依赖库的版本和哈希值。</li>
</ol>
<blockquote>
<p>新项目</p>
</blockquote>
<p>对于一个新创建的项目，可以在项目文件夹下按照以下步骤操作：</p>
<ol>
<li>执行<code>go mod init 项目名</code>命令，在当前项目文件夹下创建一个<code>go.mod</code>文件。</li>
<li>手动编辑<code>go.mod</code>中的require依赖项或执行<code>go get</code>自动发现、维护依赖。</li>
</ol>
<h2 id="使用go-module导入本地包"><a href="#使用go-module导入本地包" class="headerlink" title="使用go module导入本地包"></a>使用go module导入本地包</h2><p>假设存在两个包：demo和test，其中demo包中会导入test包并使用其方法。</p>
<p><strong>test/test.go</strong></p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> test

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

fun <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"test.Test()"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>在同一个项目下</p>
</blockquote>
<p><strong>目录结构</strong>：</p>
<pre class=" language-bash"><code class="language-bash">demo
├── go.mod
├── main.go
└── <span class="token function">test</span>
    └── test.go</code></pre>
<p><strong>1、导入包</strong>；</p>
<p>在<code>demo/go.mod</code>中按如下定义：</p>
<pre class=" language-go"><code class="language-go">module demo

<span class="token keyword">go</span> <span class="token number">1.16</span></code></pre>
<p>然后再<code>demo/main.go</code>中按如下方式导入test：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"demo/test"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    test<span class="token punctuation">.</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"main.main()"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>不在同一个项目下</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash">├── demo
│   ├── go.mod
│   └── main.go
└── <span class="token function">test</span>
    ├── go.mod
    └── test.go</code></pre>
<p><strong>1、导入包</strong>；</p>
<p>对demo和test进行module初始化（也就是对这两个项目分别进行<code>go mod init</code>），然后在<code>demo/main.go</code>中按如下方式导入：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"test"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    test<span class="token punctuation">.</span><span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">"main.main()"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>2、指定test包的路径</strong></p>
<p>因为这两个包不在同一个项目路径下，想要导入本地包，并且这些包也没有发布到远程的github或其他代码仓库地址。这个时候就需要在<code>go.mod</code>文件中使用<code>replace</code>指令。</p>
<p>在调用方<code>demo/go.mod</code>中按如下方式指定使用相对路径来寻找<code>test</code>包：</p>
<pre class=" language-go"><code class="language-go">module demo

<span class="token keyword">go</span> <span class="token number">1.16</span>

require <span class="token string">"test"</span> v0<span class="token number">.0</span><span class="token punctuation">.</span><span class="token number">0</span>
replace <span class="token string">"test"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"../test"</span></code></pre>
<h1 id="四、Go基础"><a href="#四、Go基础" class="headerlink" title="四、Go基础"></a>四、Go基础</h1><h2 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h2><h3 id="1、Go语言的主要特征"><a href="#1、Go语言的主要特征" class="headerlink" title="1、Go语言的主要特征"></a>1、Go语言的主要特征</h3><ul>
<li>自动立即回收</li>
<li>更丰富的内置类型</li>
<li>函数多返回值</li>
<li>错误处理</li>
<li>匿名函数和闭包</li>
<li>类型和接口</li>
<li>并发编程</li>
<li>反射</li>
<li>语言交互性</li>
</ul>
<h3 id="2、Go语言命名"><a href="#2、Go语言命名" class="headerlink" title="2、Go语言命名"></a>2、Go语言命名</h3><p><strong>1、Go的函数、变量、常量、自定义类型、包<code>(package)</code>的命名方式遵循以下规则：</strong></p>
<ul>
<li>首字符可以是任意的Unicode字符或者下划线</li>
<li>剩余字符可以是Unicode字符、下划线、数字</li>
<li>字符长度不限</li>
</ul>
<p><strong>2、Go只有25个关键字</strong></p>
<pre><code>break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var</code></pre><p><strong>3、Go还有37个保留字</strong></p>
<pre><code>Constants:    true  false  iota  nil

Types:    int  int8  int16  int32  int64  
uint  uint8  uint16  uint32  uint64  uintptr
float32  float64  complex128  complex64
bool  byte  rune  string  error

Functions:   make  len  cap  new  append  copy  close  delete
complex  real  imag
panic  recover</code></pre><p><strong>4、可见性</strong></p>
<ul>
<li>声明在函数内部，是函数的本地值，类似<code>private</code></li>
<li>声明在函数外部，是对当前包可见(包内所有<code>.go</code>文件都可见)的全局值，类似<code>protect</code></li>
<li>声明在函数外部且首字母大写是所有包可见的全局值,类似<code>public</code></li>
</ul>
<h3 id="3、Go语言声明"><a href="#3、Go语言声明" class="headerlink" title="3、Go语言声明"></a>3、Go语言声明</h3><p>有四种主要声明方式：</p>
<ul>
<li><code>var</code>声明变量</li>
<li><code>onst</code>声明常量）</li>
<li><code>type</code>声明类型</li>
<li><code>func</code>声明函数</li>
</ul>
<p>Go的程序是保存在多个.go文件中，文件的第一行就是package XXX声明，用来说明该文件属于哪个包(package)，package声明下来就是import声明，再下来是类型，变量，常量，函数的声明。‘</p>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p><code>_</code>是特殊标识符，用来忽略结果。</p>
<h3 id="1、在import中"><a href="#1、在import中" class="headerlink" title="1、在import中"></a>1、在import中</h3><p>当导入一个包时，该包下的文件里所有<code>init()</code>函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行<code>init()</code>函数而已。这个时候就可以使用<code>import</code>引用该包。即使用<code>import _ 包路径</code>只是引用该包，仅仅是为了调用<code>init()</code>函数，所以无法通过包名来调用包中的其他函数。</p>
<h3 id="2、在代码中"><a href="#2、在代码中" class="headerlink" title="2、在代码中"></a>2、在代码中</h3><blockquote>
<p>解释一</p>
</blockquote>
<p>下划线意思是忽略这个变量。比如os.Open，返回值为<code>*os.File，error</code>    </p>
<p>普通写法：</p>
<pre class=" language-go"><code class="language-go">f<span class="token punctuation">,</span>err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"xxxxxxx"</span><span class="token punctuation">)</span></code></pre>
<p>如果此时不需要知道返回的错误值，就可以用</p>
<pre class=" language-go"><code class="language-go">f<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"xxxxxx"</span><span class="token punctuation">)</span> </code></pre>
<p>如此则忽略了<code>error</code>变量。</p>
<blockquote>
<p>解释二</p>
</blockquote>
<p>   占位符，意思是那个位置本应赋给某个值，但是咱们不需要这个值。所以就把该值赋给下划线，意思是丢掉不要。这样编译器可以更好的优化，任何类型的单个值都可以丢给下划线。这种情况是占位用的，方法返回两个结果，而你只想要一个结果。那另一个就用<code>_</code> 占位，而如果用变量的话，不使用，编译器是会报错的。</p>
<blockquote>
<p>补充</p>
</blockquote>
<pre class=" language-go"><code class="language-go"><span class="token keyword">import</span> <span class="token string">"database/sql"</span>
<span class="token keyword">import</span> <span class="token boolean">_</span> <span class="token string">"github.com/go-sql-driver/mysql"</span></code></pre>
<p>第二个import就是不直接使用mysql包，只是执行一下这个包的init函数，把mysql的驱动注册到sql包里，然后程序里就可以使用sql包来访问mysql数据库了。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>在 Go 编程语言中，数据类型用于声明函数和变量。</p>
<p>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p>
<p>Go语言中有丰富的数据类型，除了基本的整型、浮点型、布尔型、字符串外，还有数组、切片、结构体、函数、map、通道（channel）等。Go 语言的基本类型和其他语言大同小异。</p>
<h3 id="1、整型"><a href="#1、整型" class="headerlink" title="1、整型"></a>1、整型</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uint8</td>
<td align="center">无符号 8位整型 (0 到 255)</td>
</tr>
<tr>
<td align="center">uint16</td>
<td align="center">无符号 16位整型 (0 到 65535)</td>
</tr>
<tr>
<td align="center">uint32</td>
<td align="center">无符号 32位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td align="center">uint64</td>
<td align="center">无符号 64位整型 (0 到 18446744073709551615)</td>
</tr>
<tr>
<td align="center">int8</td>
<td align="center">有符号 8位整型 (-128 到 127)</td>
</tr>
<tr>
<td align="center">int16</td>
<td align="center">有符号 16位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td align="center">int32</td>
<td align="center">有符号 32位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td align="center">int64</td>
<td align="center">有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody></table>
<blockquote>
<p>特殊整型</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uint</td>
<td align="center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td>
</tr>
<tr>
<td align="center">uintptr</td>
<td align="center">无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在不同平台上的差异。</p>
<p><strong>注意事项</strong>：获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</p>
<h3 id="2、浮点型"><a href="#2、浮点型" class="headerlink" title="2、浮点型"></a>2、浮点型</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float32</td>
<td align="center">遵循<code>IEEE 754</code>标准，最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code></td>
</tr>
<tr>
<td align="center">float64</td>
<td align="center">遵循<code>IEEE 754</code>标准，最大范围约为<code>1.8e308</code>，可以使用常量定义：<code>math.MaxFloat64</code></td>
</tr>
</tbody></table>
<p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>。</p>
<h3 id="3、复数"><a href="#3、复数" class="headerlink" title="3、复数"></a>3、复数</h3><p>在计算机中，复数是由两个浮点数表示的，其中一个表示实部（real），一个表示虚部（imag）</p>
<p><code>complex64</code>的实部和虚部为<code>32位</code>，<code>complex128</code>的实部和虚部为<code>64位</code>，其中 complex128 为复数的默认类型。</p>
<p>复数的值由三部分组成 RE + IMi，其中 RE 是实数部分，IM 是虚数部分，RE 和 IM 均为 float 类型，而最后的 i 是虚数单位。</p>
<p><strong>声明复数的语法格式如下所示：</strong></p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> name <span class="token builtin">complex128</span> <span class="token operator">=</span> <span class="token function">complex</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span></code></pre>
<p>其中<code>name</code>为复数的变量名，<code>complex128</code>为复数的类型，<code>=</code>后面的<code>complex</code>为Go语言的内置函数用于为复数赋值，<code>x</code>、<code>y</code>分别表示构成该复数的两个<code>float64</code>类型的数值，<code>x</code>为实部，<code>y</code>为虚部。</p>
<p>上面的声明语句也可以简写为下面的形式：</p>
<pre class=" language-go"><code class="language-go">name <span class="token operator">:=</span> <span class="token function">complex</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span></code></pre>
<p>对于一个复数<code>z := complex(x, y)</code>，可以通过Go语言的内置函数<code>real(z)</code>来获得该复数的实部，也就是 <code>x</code>；通过<code>imag(z)</code>获得该复数的虚部，也就是<code>y</code>。</p>
<h3 id="4、布尔型"><a href="#4、布尔型" class="headerlink" title="4、布尔型"></a>4、布尔型</h3><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true</code>和<code>false</code>两个值。</p>
<p>布尔值可以和<code>&amp;&amp;</code>（AND）和<code>||</code>（OR）操作符结合，并且有短路行为，如果运算符左边的值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：</p>
<pre class=" language-go"><code class="language-go">s <span class="token operator">!=</span> <span class="token string">""</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'x'</span></code></pre>
<p>其中<code>s[0]</code>操作如果应用于空字符串将会导致<code>panic</code>异常。</p>
<p>因为<code>&amp;&amp;</code>的优先级比<code>||</code>高（&amp;&amp; 对应逻辑乘法，|| 对应逻辑加法，乘法比加法优先级要高），所以下面的布尔表达式可以不加小括号：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">if</span> <span class="token string">'a'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token string">'z'</span> <span class="token operator">||</span>
    <span class="token string">'A'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token string">'Z'</span> <span class="token operator">||</span>
    <span class="token string">'0'</span> <span class="token operator">&lt;=</span> c <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token string">'9'</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...ASCII字母或数字...</span>
<span class="token punctuation">}</span></code></pre>
<p>布尔值并不会隐式转换为数字值 0 或 1，反之亦然，必须使用 if 语句显式的进行转换：</p>
<pre class=" language-go"><code class="language-go">i <span class="token operator">:=</span> <span class="token number">0</span>
<span class="token keyword">if</span> b <span class="token punctuation">{</span>
    i <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">}</span></code></pre>
<p>如果需要经常做类似的转换，可以将转换的代码封装成一个函数，如下所示：</p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 如果b为真，btoi返回1；如果为假，btoi返回0</span>
<span class="token keyword">func</span> <span class="token function">btoi</span><span class="token punctuation">(</span>b <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> b <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token punctuation">}</span></code></pre>
<p>数字到布尔型的逆转换非常简单，不过为了保持对称，我们也可以封装一个函数：</p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// itob报告是否为非零。</span>
<span class="token keyword">func</span> <span class="token function">itob</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span> 
    <span class="token keyword">return</span> i <span class="token operator">!=</span> <span class="token number">0</span> 
<span class="token punctuation">}</span></code></pre>
<p><strong>注意：</strong></p>
<ol>
<li>布尔类型变量的默认值为<code>false</code>。</li>
<li>Go 语言中不允许将整型强制转换为布尔型。</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li>
</ol>
<h3 id="5、字符串"><a href="#5、字符串" class="headerlink" title="5、字符串"></a>5、字符串</h3><p> Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码。 字符串的值为双引号<code>"</code>中的内容，可以在Go语言的源码中直接添加非<code>ASCII</code>码字符，例如：</p>
<pre class=" language-go"><code class="language-go">s1 <span class="token operator">:=</span> <span class="token string">"hello"</span>
s2 <span class="token operator">:=</span> <span class="token string">"Go,你好"</span></code></pre>
<blockquote>
<p>字符串转义符</p>
</blockquote>
<p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">转义符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\r</code></td>
<td align="center">回车符（返回行首）</td>
</tr>
<tr>
<td align="center"><code>\n</code></td>
<td align="center">换行符（直接跳到下一行的同列位置）</td>
</tr>
<tr>
<td align="center"><code>\t</code></td>
<td align="center">制表符</td>
</tr>
<tr>
<td align="center"><code>\'</code></td>
<td align="center">单引号</td>
</tr>
<tr>
<td align="center"><code>\"</code></td>
<td align="center">双引号</td>
</tr>
<tr>
<td align="center"><code>\\</code></td>
<td align="center">反斜杠</td>
</tr>
</tbody></table>
<p>举个例子，我们要打印一个Windows平台下的一个文件路径：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"str := \"C:\\Users\\lskj\\Desktop\""</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>多行字符串</p>
</blockquote>
<p>Go语言中要定义一个多行字符串时，就必须使用<code>反引号</code>字符：</p>
<pre class=" language-go"><code class="language-go">s1 <span class="token operator">:=</span> <span class="token string">`第一行
第二行
第三行
`</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span></code></pre>
<p>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</p>
<blockquote>
<p>字符串的常用操作</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">len(str)</td>
<td align="center">求长度</td>
</tr>
<tr>
<td align="center">+或fmt.Sprintf</td>
<td align="center">拼接字符串</td>
</tr>
<tr>
<td align="center">strings.Split</td>
<td align="center">分割</td>
</tr>
<tr>
<td align="center">strings.contains</td>
<td align="center">判断是否包含</td>
</tr>
<tr>
<td align="center">strings.HasPrefix,strings.HasSuffix</td>
<td align="center">前缀/后缀判断</td>
</tr>
<tr>
<td align="center">strings.Index(),strings.LastIndex()</td>
<td align="center">子串出现的位置</td>
</tr>
<tr>
<td align="center">strings.Join(a[]string, sep string)</td>
<td align="center">join操作</td>
</tr>
</tbody></table>
<h3 id="6、byte与rune类型"><a href="#6、byte与rune类型" class="headerlink" title="6、byte与rune类型"></a>6、byte与rune类型</h3><ul>
<li><p><code>byte</code>类似<code>uint8</code>，一般用于强调数值是一个原始的数据而不是一个小的整数，代表了<code>ASCII码</code>的一个字符。</p>
</li>
<li><p><code>rune</code>通常用于表示一个Unicode码点，代表一个<code>UTF-8</code>字符。当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。<code>rune</code>类型实际是一个<code>int32</code>。</p>
</li>
</ul>
<p>组成每个字符串的元素叫做<strong>字符</strong>，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号<code>'</code>包裹起来。 </p>
<p>字符串底层是一个<code>byte</code>数组，所以可以和<code>[]byte</code>类型相互转换。字符串是不能修改的字符串是由<code>byte</code>字节组成，所以字符串的长度是<code>byte</code>字节的长度。 <code>rune</code>类型用来表示<code>utf8</code>字符，一个<code>rune</code>字符由一个或多个byte组成。</p>
<h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">changeString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    s1 <span class="token operator">:=</span> <span class="token string">"hello"</span>
    <span class="token comment" spellcheck="true">// 强制类型转换</span>
    byteS1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span>
    byteS1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'H'</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>byteS1<span class="token punctuation">)</span><span class="token punctuation">)</span>

    s2 <span class="token operator">:=</span> <span class="token string">"男生"</span>
    runeS2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span>
    runeS2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'女'</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>runeS2<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。</p>
<p>强制类型转换的基本语法如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token function">T</span><span class="token punctuation">(</span>表达式<span class="token punctuation">)</span></code></pre>
<p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等。</p>
<pre class=" language-go"><code class="language-go">类型B的值 <span class="token operator">=</span> 类型<span class="token function">B</span><span class="token punctuation">(</span>类型A的值<span class="token punctuation">)</span></code></pre>
<ul>
<li>类型转换只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将 int16 转换为 int32）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。</li>
<li>浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。</li>
</ul>
<h3 id="数字字面量语法"><a href="#数字字面量语法" class="headerlink" title="数字字面量语法"></a>数字字面量语法</h3><p>数字字面量语法（Number literals syntax）。Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：</p>
<p><code>v := 0b00101101</code>， 代表二进制的 101101，相当于十进制的 45。 <code>v := 0o377</code>，代表八进制的 377，相当于十进制的 255。 <code>v := 0x1p-2</code>，代表十六进制的 1 除以 2²，也就是 0.25。</p>
<p>而且还允许我们用 <code>_</code> 来分隔数字，比如说： <code>v := 123_456</code> 表示 v 的值等于 123456。</p>
<p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 十进制</span>
    <span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d \n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 10</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%b \n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 1010  占位符%b表示二进制</span>

    <span class="token comment" spellcheck="true">// 八进制  以0开头</span>
    <span class="token keyword">var</span> b <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">077</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%o \n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 77</span>

    <span class="token comment" spellcheck="true">// 十六进制  以0x开头</span>
    <span class="token keyword">var</span> c <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">0xff</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%x \n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// ff</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%X \n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// FF</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="内置类型和函数"><a href="#内置类型和函数" class="headerlink" title="内置类型和函数"></a>内置类型和函数</h2><h3 id="1、内置类型"><a href="#1、内置类型" class="headerlink" title="1、内置类型"></a>1、内置类型</h3><blockquote>
<p>值类型</p>
</blockquote>
<pre><code>bool
int(32 or 64), int8, int16, int32, int64
uint(32 or 64), uint8(byte), uint16, uint32, uint64
float32, float64
string
complex64, complex128
array    -- 固定长度的数组</code></pre><blockquote>
<p>引用类型（指针类型）</p>
</blockquote>
<pre><code>slice   -- 序列数组(最常用)
map     -- 映射
chan    -- 管道</code></pre><h3 id="2、内置函数"><a href="#2、内置函数" class="headerlink" title="2、内置函数"></a>2、内置函数</h3><p>Go 语言拥有一些不需要进行导入操作就可以使用的内置函数。它们有时可以针对不同的类型进行操作，例如：len、cap 和 append，或必须用于系统级的操作，例如：panic。因此，它们需要直接获得编译器的支持。</p>
<pre><code>append          -- 用来追加元素到数组、slice中,返回修改后的数组、slice
close           -- 主要用来关闭channel
delete            -- 从map中删除key对应的value
panic            -- 停止常规的goroutine  （panic和recover：用来做错误处理）
recover         -- 允许程序定义goroutine的panic动作
real            -- 返回complex的实部   （complex、real imag：用于创建和操作复数）
imag            -- 返回complex的虚部
make            -- 用来分配内存，返回Type本身(只能应用于slice, map, channel)
new                -- 用来分配内存，主要用来分配值类型，比如int、struct。返回指向Type的指针
cap                -- capacity是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）
copy            -- 用于复制和连接slice，返回复制的数目
len                -- 来求长度，比如string、array、slice、map、channel ，返回长度
print、println     -- 底层打印函数，在部署环境中建议使用 fmt 包</code></pre><blockquote>
<p>内置接口error</p>
</blockquote>
<pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> <span class="token builtin">error</span> <span class="token keyword">interface</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//只要实现了Error()函数，返回值为String的都实现了err接口</span>
    <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    String
<span class="token punctuation">}</span></code></pre>
<h2 id="init函数与main函数"><a href="#init函数与main函数" class="headerlink" title="init函数与main函数"></a>init函数与main函数</h2><h3 id="1、init函数"><a href="#1、init函数" class="headerlink" title="1、init函数"></a>1、init函数</h3><p>go语言中<code>init</code>函数用于包<code>(package)</code>的初始化，该函数是go语言的一个重要特性。</p>
<ul>
<li>init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等</li>
<li>每个包可以拥有多个init函数</li>
<li>包的每个源文件也可以拥有多个init函数 </li>
<li>同一个包中多个init函数的执行顺序go语言没有明确的定义(说明)</li>
<li>不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序</li>
<li>init函数不能被其他函数调用，而是在main函数执行之前，自动被调用</li>
</ul>
<h3 id="2、main函数"><a href="#2、main函数" class="headerlink" title="2、main函数"></a>2、main函数</h3><p>Go语言程序的默认入口函数(主函数)：<code>func main()</code>，函数体用<code>{}</code>一对括号包裹。</p>
<blockquote>
<p>init函数与main函数的异同</p>
</blockquote>
<p><strong>相同点</strong>：两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。</p>
<p><strong>不同点</strong>：</p>
<ul>
<li>init可以应用于任意包中，且可以重复定义多个。</li>
<li>main函数只能用于main包中，且只能定义一个。</li>
</ul>
<p><strong>执行顺序</strong>：</p>
<ul>
<li><p>对同一个go文件的<code>init()</code>调用顺序是从上到下的。</p>
</li>
<li><p>对同一个package中不同文件是按文件名字符串比较<strong>从小到大</strong>顺序调用各文件中的<code>init()</code>函数。</p>
</li>
<li><p>对于不同的<code>package</code>，如果不相互依赖的话，按照main包中”先<code>import</code>的后调用”的顺序调用其包中的<code>init()</code>，如果<code>package</code>存在依赖，则先调用最早被依赖的<code>package</code>中的<code>init()</code>，最后调用<code>main</code>函数。</p>
</li>
</ul>
<p>如果<code>init</code>函数中使用了<code>println()</code>或者<code>print()</code>，在执行过程中这两个不会按照想象中的顺序执行。这两个函数官方只推荐在测试环境中使用，对于正式环境不要使用。</p>
<h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="1、变量"><a href="#1、变量" class="headerlink" title="1、变量"></a>1、变量</h3><blockquote>
<p>标准格式</p>
</blockquote>
<p>Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。声明变量的一般形式是使用<code>var</code>关键字，<strong>行尾无需分号</strong>：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> 变量名 变量类型</code></pre>
<p>变量初始化：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> 变量名 类型 <span class="token operator">=</span> 表达式</code></pre>
<blockquote>
<p>批量格式</p>
</blockquote>
<p>变量声明时可以声明多个变量：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>
    a <span class="token builtin">string</span>
    b <span class="token builtin">int</span>
    c <span class="token builtin">bool</span>
    d <span class="token builtin">float32</span>
<span class="token punctuation">)</span></code></pre>
<blockquote>
<p>简短格式</p>
</blockquote>
<p>除 var 关键字外，还可使用更加简短的变量定义和初始化语法。</p>
<pre class=" language-go"><code class="language-go">名字 <span class="token operator">:=</span> 表达式</code></pre>
<p>需要注意的是，简短格式有以下限制：</p>
<ul>
<li>定义变量，同时显式初始化。</li>
<li>不能提供数据类型。</li>
<li>只能用在函数内部。</li>
</ul>
<p>和<code>var</code>形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量。</p>
<p><strong>注</strong>：</p>
<ul>
<li>指定变量类型，如果没有初始化，则变量默认为零值。</li>
<li>将变量的类型省略时，编译器会根据值自行判定变量类型。</li>
<li>如果变量已经使用 var 声明过了，再使用 <code>:=</code>声明变量，就产生编译错误。</li>
</ul>
<blockquote>
<p>匿名变量</p>
</blockquote>
<p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示（<code>_</code>本身就是一个特殊的标识符，被称为空白标识符），例如：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">"Q1mi"</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token boolean">_</span><span class="token punctuation">,</span> y <span class="token operator">:=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"x="</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"y="</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。</p>
<p><strong>注</strong>：</p>
<ul>
<li>函数外的每个语句都必须以关键字开始（<code>var</code>、<code>const</code>、<code>func</code>等）</li>
<li><code>:=</code>不能使用在函数外</li>
<li><code>_</code>多用于占位，表示忽略值</li>
</ul>
<blockquote>
<p>变量的作用域</p>
</blockquote>
<p>根据变量定义位置的不同，可以分为以下三个类型：</p>
<ul>
<li>函数内定义的变量称为局部变量</li>
<li>函数外定义的变量称为全局变量</li>
<li>函数定义中的变量称为形式参数</li>
</ul>
<h3 id="2、常量"><a href="#2、常量" class="headerlink" title="2、常量"></a>2、常量</h3><p>常量的定义格式和变量的声明语法类似：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">const</span> 常量名 常量类型 <span class="token operator">=</span> 值</code></pre>
<p>常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。</p>
<p>与变量声明一样，也可以批量声明多个常量：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>
    pi <span class="token operator">=</span> <span class="token number">3.1415926</span>
    title <span class="token operator">=</span> <span class="token string">"test"</span>
<span class="token punctuation">)</span></code></pre>
<p>所有常量的运算都可以在编译期完成，这样不仅可以减少运行时的工作，也方便其他代码的编译优化，当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。</p>
<p>常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：<code>len</code>、<code>cap</code>、<code>real</code>、<code>imag</code>、<code>complex</code> 和<code>unsafe.Sizeof</code>。</p>
<blockquote>
<p>iota</p>
</blockquote>
<p><code>iota</code>是go语言的常量计数器，只能在常量的表达式中使用。</p>
<p>常量声明可以使用<code>iota</code>常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const 声明语句中，在第一个声明的常量所在的行，iota 将会被置为 0，然后在每一个有常量声明的行加一。</p>
<p>定义一个 Weekday 命名类型，然后为一周的每天定义了一个常量，从周日 0 开始:</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> Weekday <span class="token builtin">int</span>
<span class="token keyword">const</span> <span class="token punctuation">(</span>
    Sunday Weekday <span class="token operator">=</span> <span class="token boolean">iota</span>
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
<span class="token punctuation">)</span></code></pre>
<p>在其它编程语言中，这种类型一般被称为枚举类型。</p>
<p><strong>常见的iota示例</strong>：</p>
<p>使用<code>_</code>跳过某些值</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>
    n1 <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment" spellcheck="true">//0</span>
    n2        <span class="token comment" spellcheck="true">//1</span>
    <span class="token boolean">_</span>
    n4        <span class="token comment" spellcheck="true">//3</span>
<span class="token punctuation">)</span></code></pre>
<p><code>iota</code>声明中间插队</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>
    n1 <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment" spellcheck="true">//0</span>
    n2 <span class="token operator">=</span> <span class="token number">100</span>  <span class="token comment" spellcheck="true">//100</span>
    n3 <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment" spellcheck="true">//2</span>
    n4        <span class="token comment" spellcheck="true">//3</span>
<span class="token punctuation">)</span>
<span class="token keyword">const</span> n5 <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment" spellcheck="true">//0</span></code></pre>
<p>定义数量级 （这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的二进制表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是十进制的1024。同理<code>2&lt;&lt;2</code>表示将2的二进制表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是十进制的8。）</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>
    <span class="token boolean">_</span>  <span class="token operator">=</span> <span class="token boolean">iota</span>
    KB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token boolean">iota</span><span class="token punctuation">)</span>
    MB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token boolean">iota</span><span class="token punctuation">)</span>
    GB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token boolean">iota</span><span class="token punctuation">)</span>
    TB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token boolean">iota</span><span class="token punctuation">)</span>
    PB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token boolean">iota</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span></code></pre>
<p>多个<code>iota</code>定义在一行</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>
    a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">iota</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token comment" spellcheck="true">//1,2</span>
    c<span class="token punctuation">,</span> d                      <span class="token comment" spellcheck="true">//2,3</span>
    e<span class="token punctuation">,</span> f                      <span class="token comment" spellcheck="true">//3,4</span>
<span class="token punctuation">)</span></code></pre>
<blockquote>
<p>无类型常量</p>
</blockquote>
<p>Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如<code>int</code>或<code>float64</code>，或者是类似<code>time.Duration</code>这样的基础类型，但是许多常量并没有一个明确的基础类型。</p>
<p>编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有<code>256bit</code>的运算精度。这里有六种未明确类型的常量类型，分别是<strong>无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串</strong>。</p>
<p>通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。</p>
<p>例：<code>math.Pi</code>无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">float32</span> <span class="token operator">=</span> math<span class="token punctuation">.</span>Pi
<span class="token keyword">var</span> y <span class="token builtin">float64</span> <span class="token operator">=</span> math<span class="token punctuation">.</span>Pi
<span class="token keyword">var</span> z <span class="token builtin">complex128</span> <span class="token operator">=</span> math<span class="token punctuation">.</span>Pi</code></pre>
<p>如果<code>math.Pi</code>被确定为特定类型，比如 <code>float64</code>，那么结果精度可能会不一样，同时对于需要<code>float32</code>或<code>complex128</code>类型值的地方则需要一个明确的强制类型转换：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">const</span> Pi64 <span class="token builtin">float64</span> <span class="token operator">=</span> math<span class="token punctuation">.</span>Pi
<span class="token keyword">var</span> x <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token function">float32</span><span class="token punctuation">(</span>Pi64<span class="token punctuation">)</span>
<span class="token keyword">var</span> y <span class="token builtin">float64</span> <span class="token operator">=</span> Pi64
<span class="token keyword">var</span> z <span class="token builtin">complex128</span> <span class="token operator">=</span> <span class="token function">complex128</span><span class="token punctuation">(</span>Pi64<span class="token punctuation">)</span></code></pre>
<p>对于常量面值，不同的写法可能会对应不同的类型。例如 <code>0</code>、<code>0.0</code>、<code>0i</code> 和 <code>\u0000</code>虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，<code>true</code>和<code>false</code>也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。</p>
<h1 id="五、Go容器"><a href="#五、Go容器" class="headerlink" title="五、Go容器"></a>五、Go容器</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，所以在Go语言中很少直接使用数组。</p>
<p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值</p>
<p>数组的声明语法如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> 数组变量名 <span class="token punctuation">[</span>元素数量<span class="token punctuation">]</span>变量类型</code></pre>
<ul>
<li>数组变量名：数组声明及使用时的变量名。</li>
<li>元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。</li>
<li>变量类型：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。</li>
</ul>
<p>数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减1（len-1）的位置，内置函数<code>len()</code>可以返回数组中元素的个数，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p>
<h3 id="1、数组的遍历"><a href="#1、数组的遍历" class="headerlink" title="1、数组的遍历"></a>1、数组的遍历</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span>

<span class="token comment" spellcheck="true">// for循环遍历</span>
<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// for range遍历</span>
<span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说就是 0，同时也可以使用数组字面值语法，用一组值来初始化数组。</li>
<li>在数组的定义中，如果在数组长度的位置出现“…”省略号，则表示数组的长度是根据初始化值的个数来计算。</li>
<li>数组的长度是数组类型的一个组成部分，因此 [3]int 和 [4]int 是两种不同的数组类型，数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</li>
</ul>
<h3 id="2、多维数组"><a href="#2、多维数组" class="headerlink" title="2、多维数组"></a>2、多维数组</h3><p>Go 语言支持多维数组，以下为常用的多维数组声明方式：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> 数组变量名 <span class="token punctuation">[</span>元素数量<span class="token punctuation">]</span>元素数量<span class="token punctuation">]</span><span class="token operator">...</span>元素数量<span class="token punctuation">]</span> 变量类型</code></pre>
<p> 多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度。</p>
<blockquote>
<p>比较两个数组是否相等</p>
</blockquote>
<p>如果两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，我们可以直接通过较运算符（<code>==</code>和<code>!=</code>）来判断两个数组是否相等，只有当两个数组的所有元素都是相等的时候数组才是相等的，不能比较两个类型不同的数组，否则程序将无法完成编译。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>Go 语言切片是对数组的抽象。</p>
<p>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p>
<p>切片（slice）是对数组的一个连续片段的引用，所以切片是一个引用类型，这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，需要注意的是，终止索引标识的项不包括在切片内。</p>
<p>切片的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p>
<h3 id="1、定义切片"><a href="#1、定义切片" class="headerlink" title="1、定义切片"></a>1、定义切片</h3><blockquote>
<p>声明未指定大小的数组来定义切片</p>
</blockquote>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> 变量名 <span class="token punctuation">[</span><span class="token punctuation">]</span>T</code></pre>
<p>T：表示切片中的元素类型。切片不需要说明长度。</p>
<blockquote>
<p>使用make()函数来创建切片</p>
</blockquote>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> slice1 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">//可以简写为</span>
slice1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">type</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">)</span></code></pre>
<p>也可以指定容量，其中<code>capacity</code>为可选参数。</p>
<pre class=" language-go"><code class="language-go"><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>T<span class="token punctuation">,</span> length<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span></code></pre>
<p>这里<code>len</code>是数组的长度并且也是切片的初始长度。</p>
<p>使<code>make()</code>函数生成的切片一定发生了内存分配操作，但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。</p>
<h3 id="2、切片初始化"><a href="#2、切片初始化" class="headerlink" title="2、切片初始化"></a>2、切片初始化</h3><pre class=" language-go"><code class="language-go">s <span class="token operator">:=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span> </code></pre>
<p>直接初始化切片，<code>[]</code>表示是切片类型，<code>{1,2,3}</code> 初始化值依次是 <strong>1,2,3</strong>，其 <code>cap=len=3</code>。</p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//生成切片的格式中，当开始和结束位置都被忽略时，生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上也是一致的</span>
s <span class="token operator">:=</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//表示原有的切片。arr[0:0]，表示重置切片，清空拥有的元素。把切片的开始和结束位置都设为0时，生成的切片将变空</span>

<span class="token comment" spellcheck="true">//初始化切片 s ，是数组 arr 的引用</span>
s <span class="token operator">:=</span> arr<span class="token punctuation">[</span>startIndex<span class="token punctuation">:</span>endIndex<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true">//将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片</span>
<span class="token comment" spellcheck="true">//默认 startIndex 时将表示从 arr 的第一个元素开始</span>
s <span class="token operator">:=</span> arr<span class="token punctuation">[</span>startIndex<span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token comment" spellcheck="true">//默认 endIndex 时将表示一直到arr的最后一个元素</span>
s <span class="token operator">:=</span> arr<span class="token punctuation">[</span><span class="token punctuation">:</span>endIndex<span class="token punctuation">]</span>

<span class="token comment" spellcheck="true">//通过切片 s 初始化切片 s1</span>
s1 <span class="token operator">:=</span> s<span class="token punctuation">[</span>startIndex<span class="token punctuation">:</span>endIndex<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true">//通过内置函数make()初始化切片s，[]int标识为其元素类型为int的切片</span>
s <span class="token operator">:=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">,</span><span class="token builtin">cap</span><span class="token punctuation">)</span></code></pre>
<h3 id="3、len-和cap"><a href="#3、len-和cap" class="headerlink" title="3、len()和cap()"></a>3、len()和cap()</h3><p>切片是可索引的，可以由<code>len()</code>获取长度。</p>
<p>切片提供了计算容量的方法<code>cap()</code>可以测量切片最长可以达到多少。</p>
<h3 id="4、空（nil）切片"><a href="#4、空（nil）切片" class="headerlink" title="4、空（nil）切片"></a>4、空（nil）切片</h3><p>一个切片在未初始化之前默认为<code>nil</code>，长度为<code>0</code>。</p>
<blockquote>
<p>切片不能直接比较</p>
</blockquote>
<p>切片之间是不能比较的，不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> s1 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>         <span class="token comment" spellcheck="true">//len(s1)=0;cap(s1)=0;s1==nil</span>
s2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//len(s2)=0;cap(s2)=0;s2!=nil</span>
s3 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//len(s3)=0;cap(s3)=0;s3!=nil</span></code></pre>
<p>所以判断一个切片是否为空，需使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p>
<h3 id="5、切片截取"><a href="#5、切片截取" class="headerlink" title="5、切片截取"></a>5、切片截取</h3><p>可以通过设置下限及上限来设置截取切片 *[lower-bound:upper-bound]*，实例如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/* 创建切片 */</span>
    numbers <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">}</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">/* 打印原始切片 */</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"numbers =="</span><span class="token punctuation">,</span> numbers<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"numbers[1:4] =="</span><span class="token punctuation">,</span> numbers<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">/* 默认下限为 0*/</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"numbers[:3] =="</span><span class="token punctuation">,</span> numbers<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">/* 默认上限为 len(s)*/</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"numbers[4:] =="</span><span class="token punctuation">,</span> numbers<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    numbers1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>numbers1<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span>
    number2 <span class="token operator">:=</span> numbers<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>number2<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span>
    number3 <span class="token operator">:=</span> numbers<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>number3<span class="token punctuation">)</span>

<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">printSlice</span><span class="token punctuation">(</span>x <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"len=%d cap=%d slice=%v\n"</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">cap</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>执行以上代码输出结果为：</p>
<pre class=" language-bash"><code class="language-bash">len<span class="token operator">=</span>9 cap<span class="token operator">=</span>9 slice<span class="token operator">=</span><span class="token punctuation">[</span>0 1 2 3 4 5 6 7 8<span class="token punctuation">]</span>
numbers <span class="token operator">==</span> <span class="token punctuation">[</span>0 1 2 3 4 5 6 7 8<span class="token punctuation">]</span>
numbers<span class="token punctuation">[</span>1:4<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token punctuation">[</span>1 2 3<span class="token punctuation">]</span>
numbers<span class="token punctuation">[</span>:3<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token punctuation">[</span>0 1 2<span class="token punctuation">]</span>
numbers<span class="token punctuation">[</span>4:<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token punctuation">[</span>4 5 6 7 8<span class="token punctuation">]</span>
len<span class="token operator">=</span>0 cap<span class="token operator">=</span>5 slice<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
len<span class="token operator">=</span>2 cap<span class="token operator">=</span>9 slice<span class="token operator">=</span><span class="token punctuation">[</span>0 1<span class="token punctuation">]</span>
len<span class="token operator">=</span>3 cap<span class="token operator">=</span>7 slice<span class="token operator">=</span><span class="token punctuation">[</span>2 3 4<span class="token punctuation">]</span></code></pre>
<h3 id="6、append"><a href="#6、append" class="headerlink" title="6、append()"></a>6、append()</h3><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> numbers <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">/* 允许追加空切片 */</span>
    numbers <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">/* 向切片添加一个元素 */</span>
    numbers <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">/* 同时添加多个元素 */</span>
    numbers <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span>

    s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>

    numbers <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>numbers<span class="token punctuation">,</span>s<span class="token operator">...</span><span class="token punctuation">)</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">printSlice</span><span class="token punctuation">(</span>x <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"len=%d cap=%d slice=%v\n"</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">cap</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>上述代码执行输出结果为：</p>
<pre class=" language-bash"><code class="language-bash">len<span class="token operator">=</span>0 cap<span class="token operator">=</span>0 slice<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
len<span class="token operator">=</span>1 cap<span class="token operator">=</span>1 slice<span class="token operator">=</span><span class="token punctuation">[</span>0<span class="token punctuation">]</span>
len<span class="token operator">=</span>2 cap<span class="token operator">=</span>2 slice<span class="token operator">=</span><span class="token punctuation">[</span>0 1<span class="token punctuation">]</span>
len<span class="token operator">=</span>5 cap<span class="token operator">=</span>6 slice<span class="token operator">=</span><span class="token punctuation">[</span>0 1 2 3 4<span class="token punctuation">]</span>
len<span class="token operator">=</span>3 cap<span class="token operator">=</span>3 slice<span class="token operator">=</span><span class="token punctuation">[</span>5 6 7<span class="token punctuation">]</span>
len<span class="token operator">=</span>8 cap<span class="token operator">=</span>12 slice<span class="token operator">=</span><span class="token punctuation">[</span>0 1 2 3 4 5 6 7<span class="token punctuation">]</span></code></pre>
<p>通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p>
<p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行<strong>扩容</strong>，此时该切片指向的底层数组就会更换。<strong>扩容</strong>操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p>
<ul>
<li><p><code>append()</code>函数将元素追加到切片的最后并返回该切片。</p>
</li>
<li><p>切片的容量按照1，2，4，8，16这样的规则自动进行扩容，<strong>每次扩容后都是扩容前的2倍</strong>。</p>
</li>
</ul>
<h3 id="7、copy"><a href="#7、copy" class="headerlink" title="7、copy()"></a>7、copy()</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    numbers <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">/* 创建切片 s 是之前切片的两倍容量*/</span>
    s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">/* 拷贝 numbers 的内容到 s */</span>
    <span class="token function">copy</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>numbers<span class="token punctuation">)</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>

    s1 <span class="token operator">:=</span> s
    <span class="token function">printSlice</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span>

    s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">printSlice</span><span class="token punctuation">(</span>x <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"len=%d cap=%d slice=%v\n"</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">cap</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>上述代码执行结果如下：</p>
<pre class=" language-bash"><code class="language-bash">len<span class="token operator">=</span>8 cap<span class="token operator">=</span>8 slice<span class="token operator">=</span><span class="token punctuation">[</span>0 1 2 3 4 5 6 7<span class="token punctuation">]</span>
len<span class="token operator">=</span>8 cap<span class="token operator">=</span>16 slice<span class="token operator">=</span><span class="token punctuation">[</span>0 1 2 3 4 5 6 7<span class="token punctuation">]</span>
len<span class="token operator">=</span>8 cap<span class="token operator">=</span>16 slice<span class="token operator">=</span><span class="token punctuation">[</span>0 1 2 3 4 5 6 7<span class="token punctuation">]</span>
len<span class="token operator">=</span>8 cap<span class="token operator">=</span>16 slice<span class="token operator">=</span><span class="token punctuation">[</span>1 1 2 3 4 5 6 7<span class="token punctuation">]</span>
len<span class="token operator">=</span>8 cap<span class="token operator">=</span>16 slice<span class="token operator">=</span><span class="token punctuation">[</span>1 1 2 3 4 5 6 7<span class="token punctuation">]</span></code></pre>
<p>由于切片是引用类型，所以s和s1其实都指向了同一块内存地址。修改s1的同时s的值也会发生变化。</p>
<h3 id="8、从切片中删除元素"><a href="#8、从切片中删除元素" class="headerlink" title="8、从切片中删除元素"></a>8、从切片中删除元素</h3><p>Go语言中并没有删除切片元素的专用方法，但是可以使用切片本身的特性来删除元素。</p>
<blockquote>
<p>删除指定位置元素</p>
</blockquote>
<p> 代码如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">//删除索引为0的元素</span>
    numbers <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span>
    <span class="token function">printSlice</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">printSlice</span><span class="token punctuation">(</span>x <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"len=%d cap=%d slice=%v\n"</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">cap</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>上述代码执行结果如下：</p>
<pre class=" language-bash"><code class="language-bash">len<span class="token operator">=</span>8 cap<span class="token operator">=</span>8 slice<span class="token operator">=</span><span class="token punctuation">[</span>0 1 2 3 4 5 6 7<span class="token punctuation">]</span>
len<span class="token operator">=</span>7 cap<span class="token operator">=</span>8 slice<span class="token operator">=</span><span class="token punctuation">[</span>1 2 3 4 5 6 7<span class="token punctuation">]</span></code></pre>
<p>要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code>。</p>
<blockquote>
<p>从开头位置删除</p>
</blockquote>
<p>删除开头的元素可以直接移动数据指针：</p>
<pre class=" language-go"><code class="language-go">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
a <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 删除开头1个元素</span>
a <span class="token operator">=</span> a<span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 删除开头N个元素</span></code></pre>
<p>也可以不移动数据指针，但是将后面的数据向开头移动，可以用 append 原地完成（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）：</p>
<pre class=" language-go"><code class="language-go">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
a <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 删除开头1个元素</span>
a <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 删除开头N个元素</span></code></pre>
<p>还可以用 copy() 函数来删除开头的元素：</p>
<pre class=" language-go"><code class="language-go">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
a <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">copy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 删除开头1个元素</span>
a <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">copy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token punctuation">[</span>N<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 删除开头N个元素</span></code></pre>
<blockquote>
<p>从中间位置删除</p>
</blockquote>
<p>对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用 append 或 copy 原地完成。</p>
<pre class=" language-go"><code class="language-go">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">}</span>
a <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 删除中间1个元素</span>
a <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token operator">+</span>N<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 删除中间N个元素</span>
a <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token function">copy</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 删除中间1个元素</span>
a <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token function">copy</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token operator">+</span>N<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 删除中间N个元素</span></code></pre>
<blockquote>
<p>从尾部删除</p>
</blockquote>
<pre class=" language-go"><code class="language-go">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
a <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 删除尾部1个元素</span>
a <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">-</span>N<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 删除尾部N个元素</span></code></pre>
<p>Go语言中删除切片元素的本质是，以被删除元素为分界点，将前后两个部分的内存重新连接起来。</p>
<p>连续容器的元素删除无论在任何语言中，都要将删除点前后的元素移动到新的位置，随着元素的增加，这个过程将会变得极为耗时，因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高的话，就需要考虑更换其他的容器了（如双链表等能快速从删除点删除元素）。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是一种无序的基于key-value的数据结构，Go语言中的map是引用类型，必须初始化才能使用。map是一种无序的键值对的集合。map最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p>
<p>map是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，map是无序的，我们无法决定它的返回顺序，这是因为map是使用 hash 表来实现的。</p>
<h3 id="1、定义map"><a href="#1、定义map" class="headerlink" title="1、定义map"></a>1、定义map</h3><p>以使用内建函数 make 也可以使用 map 关键字来定义map：</p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">/* 声明变量，默认 map 初始值是 nil */</span>
<span class="token keyword">var</span> 变量名 <span class="token keyword">map</span><span class="token punctuation">[</span>keyType<span class="token punctuation">]</span>valueType

<span class="token comment" spellcheck="true">/* 使用 make 函数 */</span>
变量名 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span>keyType<span class="token punctuation">]</span>valueType<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">/* 因map默认初始值为nil，需使用make()函数来分配内存,如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对 */</span>
<span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span>keyType<span class="token punctuation">]</span>valueType<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token builtin">cap</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//其中cap表示map的容量，该参数虽然不是必须的，但是应该在初始化map的时候就为其指定一个合适的容量</span></code></pre>
<ul>
<li>keyType：表示键的类型</li>
<li>valueType：表示键对应的值的类型</li>
</ul>
<p><strong>[keyType] 和 valueType 之间允许有空格</strong></p>
<h3 id="2、判断某个键是否存在"><a href="#2、判断某个键是否存在" class="headerlink" title="2、判断某个键是否存在"></a>2、判断某个键是否存在</h3><p>Go中判断map中键是否存在的写法：</p>
<pre class=" language-go"><code class="language-go">value<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span></code></pre>
<ul>
<li>value：map中该key对应的值，不存在该key，则value为其对应类型的默认值</li>
<li>ok：map中是否存在这个key</li>
</ul>
<h3 id="3、map的遍历"><a href="#3、map的遍历" class="headerlink" title="3、map的遍历"></a>3、map的遍历</h3><p>使用<code>for range</code>遍历map。例：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    language <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
    language<span class="token punctuation">[</span><span class="token string">"java"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
    language<span class="token punctuation">[</span><span class="token string">"golang"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>
    language<span class="token punctuation">[</span><span class="token string">"javascript"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> language <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>如只遍历值，可以使用下面的形式（将不需要的键使用<code>_</code>改为匿名变量形式）：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> language <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span></code></pre>
<p>只遍历键时，使用下面的形式（无须将值改为匿名变量形式，忽略值即可）：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">for</span> k <span class="token punctuation">:</span><span class="token keyword">range</span> language <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
<span class="token punctuation">}</span></code></pre>
<p>注：<strong>遍历输出元素的顺序与填充顺序无关</strong>。如果需要特定顺序的遍历结果，正确的做法是先排序。</p>
<h3 id="4、map元素的删除"><a href="#4、map元素的删除" class="headerlink" title="4、map元素的删除"></a>4、map元素的删除</h3><p>Go语言提供了一个内置函数<code>delete()</code>，用于删除容器内的元素。</p>
<p>使用<code>delete()</code>内建函数从map中删除一组键值对，delete()函数的格式如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">,</span>键<span class="token punctuation">)</span></code></pre>
<ul>
<li>map为要删除的 map 实例</li>
<li>键为要删除的 map 中键值对的键</li>
</ul>
<blockquote>
<p>清空map中的所有元素</p>
</blockquote>
<p>Go语言中并没有为 map 提供任何清空所有元素的函数、方法。清空 map 的唯一办法就是重新 make 一个新的 map，不用担心垃圾回收的效率，Go语言中的并行垃圾回收效率比写一个清空函数要高效的多。</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>列表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，列表有多种实现方法，如单链表、双链表等。</p>
<h3 id="1、初始化列表"><a href="#1、初始化列表" class="headerlink" title="1、初始化列表"></a>1、初始化列表</h3><p><code>list</code>的初始化有两种方法：分别是使用 New() 函数和 var 关键字声明，两种方法的初始化效果都是一致的。</p>
<ul>
<li><p>通过<code>container/list</code>包的<code>New()</code>函数初始化list</p>
<pre class=" language-go"><code class="language-go">变量名 <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
</li>
<li><p>通过<code>var</code>关键字声明初始化list</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> 变量名 list<span class="token punctuation">.</span>List</code></pre>
</li>
</ul>
<p>列表与切片和ma 不同的是，列表并没有具体元素类型的限制，因此，列表的元素可以是任意类型，这既带来了便利，也引来一些问题，例如给列表中放入了一个<code>interface{}</code>类型的值，取出值后，如果要将<code>interface{}</code>转换为其他类型将会发生宕机。</p>
<h3 id="2、在列表中插入元素"><a href="#2、在列表中插入元素" class="headerlink" title="2、在列表中插入元素"></a>2、在列表中插入元素</h3><p>双链表支持从队列前方或后方插入元素，分别对应的方法是<code>PushFront</code>和<code>PushBack</code>。</p>
<p>这两个方法都会返回一个<code>*list.Element</code>结构，如果在以后的使用中需要删除插入的元素，则只能通过<code>*list.Element</code>配合<code>Remove()</code>方法进行删除，这种方法可以让删除更加效率化，同时也是双链表特性之一。</p>
<p>下面代码展示如何给 list 添加元素：</p>
<pre class=" language-go"><code class="language-go">l <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//创建一个列表实例</span>
l<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span><span class="token string">"fist"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//将fist字符串插入到列表的尾部，此时列表是空的，插入后只有一个元素</span>
l<span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span><span class="token number">67</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//将数值67放入列表，此时，列表中已经存在fist元素，67这个元素将被放在fist的前面</span></code></pre>
<p>列表插入元素的方法如下：</p>
<table>
<thead>
<tr>
<th align="center">方  法</th>
<th align="center">功  能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">InsertAfter(v interface {}, mark * Element) * Element</td>
<td align="center">在 mark 点之后插入元素，mark 点由其他插入函数提供</td>
</tr>
<tr>
<td align="center">InsertBefore(v interface {}, mark * Element) *Element</td>
<td align="center">在 mark 点之前插入元素，mark 点由其他插入函数提供</td>
</tr>
<tr>
<td align="center">PushBackList(other *List)</td>
<td align="center">添加 other 列表元素到尾部</td>
</tr>
<tr>
<td align="center">PushFrontList(other *List)</td>
<td align="center">添加 other 列表元素到头部</td>
</tr>
</tbody></table>
<h3 id="3、从列表中删除元素"><a href="#3、从列表中删除元素" class="headerlink" title="3、从列表中删除元素"></a>3、从列表中删除元素</h3><p>列表插入函数的返回值会提供一个<code>*list.Element</code>结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从列表中删除元素时，需要用到这个结构进行快速删除。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"container/list"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建列表实列</span>
    l <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 尾部添加</span>
    l<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span><span class="token string">"canon"</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 头部添加</span>
    l<span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span><span class="token number">67</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 将字符串 fist 插入到列表的尾部，并将这个元素的内部结构保存到 element 变量中</span>
    element <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span><span class="token string">"fist"</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 使用 element 变量，在 element 的位置后面插入 high 字符串</span>
    l<span class="token punctuation">.</span><span class="token function">InsertAfter</span><span class="token punctuation">(</span><span class="token string">"high"</span><span class="token punctuation">,</span> element<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 使用 element 变量，在 element 的位置前面插入 noon 字符串</span>
    l<span class="token punctuation">.</span><span class="token function">InsertBefore</span><span class="token punctuation">(</span><span class="token string">"noon"</span><span class="token punctuation">,</span> element<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 移除 element 变量对应的元素</span>
    l<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>列表元素操作的过程:</p>
<table>
<thead>
<tr>
<th align="center">操作内容</th>
<th align="center">列表元素</th>
</tr>
</thead>
<tbody><tr>
<td align="center">l.PushBack(“canon”)</td>
<td align="center">canon</td>
</tr>
<tr>
<td align="center">l.PushFront(67)</td>
<td align="center">67, canon</td>
</tr>
<tr>
<td align="center">element := l.PushBack(“fist”)</td>
<td align="center">67, canon, fist</td>
</tr>
<tr>
<td align="center">l.InsertAfter(“high”, element)</td>
<td align="center">67, canon, fist, high</td>
</tr>
<tr>
<td align="center">l.InsertBefore(“noon”, element)</td>
<td align="center">67, canon, noon, fist, high</td>
</tr>
<tr>
<td align="center">l.Remove(element)</td>
<td align="center">67, canon, noon, high</td>
</tr>
</tbody></table>
<h3 id="4、遍历列表"><a href="#4、遍历列表" class="headerlink" title="4、遍历列表"></a>4、遍历列表</h3><p>遍历双链表需要配合<code>Front()</code>函数获取头元素，遍历时只要元素不为空就可以继续进行，每一次遍历都会调用元素的<code>Next()</code>函数，代码如下所示：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"container/list"</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 创建列表实列</span>
    l <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 尾部添加</span>
    l<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span><span class="token string">"canon"</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 头部添加</span>
    l<span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span><span class="token number">67</span><span class="token punctuation">)</span>

    <span class="token comment" spellcheck="true">// i:=l.Front() 表示初始赋值，只会在一开始执行一次，每次循环会进行一次 i != nil 语句判断，如果返回 false，表示退出循环，反之则会执行 i = i.Next()</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">Front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>Value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>在Go语言中，布尔类型的零值（初始值）为 false，数值类型的零值为 0，字符串类型的零值为空字符串<code>""</code>，而指针、切片、映射、通道、函数和接口的零值则是<code>nil</code>。</p>
<p><code>nil</code>是Go语言中一个预定义好的标识符，开发者也许会把<code>nil</code>看作其他语言中的 null（NULL），其实这并不是完全正确的，因为Go语言中的<code>nil</code>和其他语言中的null有很多不同点。</p>
<ul>
<li>nil标识符是不能比较的</li>
<li>nil不是关键字或保留字</li>
<li>nil没有默认类型</li>
<li>不同类型的nil的指针是一样的</li>
<li>不同类型的nil是不能比较的</li>
<li>两个相同类型的nil值也可能无法比较（在Go语言中 map、slice 和 function 类型的 nil 值不能比较，比较两个无法比较类型的值是非法的）</li>
<li>nil是map、slice、pointer、channel、func、interface的零值</li>
<li>不同类型的nil值占用的内存大小可能是不一样的</li>
</ul>
<h1 id="六、流程控制"><a href="#六、流程控制" class="headerlink" title="六、流程控制"></a>六、流程控制</h1><h2 id="1、分支结构if-else"><a href="#1、分支结构if-else" class="headerlink" title="1、分支结构if else"></a>1、分支结构if else</h2><p>在Go语言中，关键字 if 是用于测试某个条件（布尔型或逻辑型）的语句，如果该条件成立，则会执行 if 后由大括号<code>{}</code>括起来的代码块，否则就忽略该代码块继续执行后续的代码。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">if</span> condition <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span></code></pre>
<p>如果存在第二个分支，则可以在上面代码的基础上添加 else 关键字以及另一代码块，这个代码块中的代码只有在条件不满足时才会执行，if 和 else 后的两个代码块是相互独立的分支，只能执行其中一个。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">if</span> condition <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span></code></pre>
<p>如果存在第三个分支，则可以使用下面这种三个独立分支的形式：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">if</span> condition1 <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> condition2 <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// d...</span>
<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span></code></pre>
<p>else if 分支的数量是没有限制的，但是为了代码的可读性，还是不要在 if 后面加入太多的 else if 结构，如果必须使用这种形式，则尽可能把先满足的条件放在前面。</p>
<p>关键字 if 和 else 之后的左大括号<code>{</code>必须和关键字在同一行，如果你使用了 else if 结构，则前段代码块的右大括号<code>}</code>必须和 else if 关键字在同一行，这两条规则都是被编译器强制规定的。</p>
<p>在有些情况下，条件语句两侧的括号是可以被省略的，当条件比较复杂时，则可以使用括号让代码更易读，在使用<code>&amp;&amp;</code>、<code>||</code>或<code>!</code> 时可以使用括号来提升某个表达式的运算优先级，并提高代码的可读性。</p>
<blockquote>
<p>特殊写法</p>
</blockquote>
<p>if 还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，代码如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">Connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span></code></pre>
<p>Connect是一个带有返回值的函数，<code>err:=Connect()</code>是一个语句，执行 Connect 后，将错误保存到 err 变量中。</p>
<p><code>err != nil</code>才是 if 的判断表达式，当 err 不为空时，打印错误并返回。</p>
<p>这种写法可以将返回值与判断放在一行进行处理，而且返回值的作用范围被限制在 if、else 语句组合中。</p>
<p>在编程中，变量的作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的地方，状态就会被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响所有代码的执行状态，因此限制变量的作用范围对代码的稳定性有很大的帮助。</p>
<h2 id="2、循环结构for"><a href="#2、循环结构for" class="headerlink" title="2、循环结构for"></a>2、循环结构for</h2><p>与多数语言不同的是，Go语言中的循环语句只支持 for 关键字，而不支持 while 和 do-while 结构。</p>
<blockquote>
<p>初始语句-开始循环时执行的语句</p>
</blockquote>
<p>初始语句是在第一次循环前执行的语句，一般使用初始语句执行变量初始化，如果变量在此处被声明，其作用域将被局限在这个 for 的范围内。</p>
<p>初始语句可以被忽略，但是初始语句之后的分号必须要写，代码如下：</p>
<pre class=" language-go"><code class="language-go">step <span class="token operator">:=</span> <span class="token number">2</span>
<span class="token keyword">for</span> <span class="token punctuation">;</span> step <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> step<span class="token operator">--</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>step<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>这段代码将 step 放在 for 的前面进行初始化，for 中没有初始语句，此时 step 的作用域就比在初始语句中声明 step 要大。</p>
<blockquote>
<p>条件表达式-控制是否循环的开关</p>
</blockquote>
<p>每次循环开始前都会计算条件表达式，如果表达式为 true，则循环继续，否则结束循环，条件表达式可以被忽略，忽略条件表达式后默认形成无限循环。</p>
<p><strong>1、结束循环时带可执行语句的无限循环</strong></p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> i <span class="token builtin">int</span>
<span class="token keyword">for</span> <span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">10</span> <span class="token punctuation">{</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>2、无线循环</strong></p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> i <span class="token builtin">int</span>
<span class="token keyword">for</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">10</span> <span class="token punctuation">{</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    i<span class="token operator">++</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>3、只有一个循环条件的循环</strong></p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> i <span class="token builtin">int</span>
<span class="token keyword">for</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span> <span class="token punctuation">{</span>
    i<span class="token operator">++</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>结束语句-每次循环结束时执行的语句</p>
</blockquote>
<p>在结束每次循环前执行的语句，如果循环被 break、goto、return、panic 等语句强制退出，结束语句不会被执行。</p>
<h2 id="3、键值循环for-range"><a href="#3、键值循环for-range" class="headerlink" title="3、键值循环for range"></a>3、键值循环for range</h2><p>for range 结构是Go语言特有的一种的迭代结构，在许多情况下都非常有用，for range 可以遍历数组、切片、字符串、map 及通道（channel），for range 语法上类似于其它语言中的 foreach 语句，一般形式为：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">for</span> key<span class="token punctuation">,</span> val <span class="token operator">:=</span> <span class="token keyword">range</span> coll <span class="token punctuation">{</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span></code></pre>
<p>注：val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值。一个字符串是 Unicode 编码的字符（或称之为 rune ）集合，因此也可以用它来迭代字符串。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">for</span> pos<span class="token punctuation">,</span> char <span class="token operator">:=</span> <span class="token keyword">range</span> str <span class="token punctuation">{</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span></code></pre>
<p>通过 for range 遍历的返回值有一定的规律：</p>
<ul>
<li>数组、切片、字符串返回索引和值。</li>
<li>map 返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ul>
<blockquote>
<p>遍历数组、切片-获得索引和值</p>
</blockquote>
<p>在遍历代码中，key 和 value 分别代表切片的下标及下标对应的值，下面的代码展示如何遍历切片，数组也是类似的遍历方法：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"key:%d  value:%d\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>遍历字符串-获得字符</p>
</blockquote>
<p>Go语言和其他语言类似，可以通过 for range 的组合，对字符串进行遍历，遍历时，key 和 value 分别代表字符串的索引和字符串中的每一个字符。</p>
<pre class=" language-go"><code class="language-go">m <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>
    <span class="token string">"first"</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
    <span class="token string">"two"</span><span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> m <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>注：对 map 遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序。</p>
<blockquote>
<p>遍历通道（channel）-接收通道数据</p>
</blockquote>
<p>for range 可以遍历通道（channel），但是通道在遍历时，只输出一个值，即管道内的类型对应的数据。</p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 创建一个整型类型的通道</span>
c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">/*
    往通道中推送数据 1、2、3，然后结束并关闭通道
*/</span>
<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c <span class="token operator">&lt;-</span> <span class="token number">1</span>
    c <span class="token operator">&lt;-</span> <span class="token number">2</span>
    c <span class="token operator">&lt;-</span> <span class="token number">3</span>
    <span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 用for range对通道c进行遍历，其实就是不断地从通道中取数据，直到通道被关闭</span>
<span class="token keyword">for</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> c <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="4、switch"><a href="#4、switch" class="headerlink" title="4、switch"></a>4、switch</h2><p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止。 Golang switch 分支表达式可以是任意类型，不限于常量。可省略 break，默认自动终止。</p>
<blockquote>
<p>语法：</p>
</blockquote>
<pre class=" language-go"><code class="language-go"><span class="token keyword">switch</span> var1 <span class="token punctuation">{</span>
    <span class="token keyword">case</span> val1<span class="token punctuation">:</span>
        <span class="token operator">...</span>
    <span class="token keyword">case</span> val2<span class="token punctuation">:</span>
        <span class="token operator">...</span>
    <span class="token keyword">default</span><span class="token punctuation">:</span>
        <span class="token operator">...</span>
<span class="token punctuation">}</span></code></pre>
<p>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。 </p>
<p><strong>1、一分支多值</strong></p>
<p>当出现多个 case 要放在一起的时：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"mum"</span>
<span class="token keyword">switch</span> a <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token string">"mum"</span><span class="token punctuation">,</span> <span class="token string">"daddy"</span><span class="token punctuation">:</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"family"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>不同的 case 表达式使用逗号分隔。</p>
<p><strong>2、分支表达式</strong></p>
<p>case 后不仅仅只是常量，还可以和 if 一样添加表达式，代码如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> r <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">11</span>
<span class="token keyword">switch</span> <span class="token punctuation">{</span>
<span class="token keyword">case</span> r <span class="token operator">></span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">:</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>上述这种情况的 switch 后面不再需要跟判断变量。</p>
<h2 id="5、goto"><a href="#5、goto" class="headerlink" title="5、goto"></a>5、goto</h2><p>Go语言中 goto 语句通过标签进行代码间的无条件跳转，同时 goto 语句在快速跳出循环、避免重复退出上也有一定的帮助，使用 goto 语句能简化一些代码的实现过程。</p>
<blockquote>
<p>使用goto退出多层循环</p>
</blockquote>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> x <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> x<span class="token operator">++</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> y <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> y<span class="token operator">++</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> y <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 跳转到标签</span>
                <span class="token keyword">goto</span> breakHere
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 手动返回, 避免执行进入标签</span>
    <span class="token keyword">return</span>
    <span class="token comment" spellcheck="true">// 标签</span>
breakHere<span class="token punctuation">:</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>使用 goto 语句后，无须额外的变量就可以快速退出所有的循环。</p>
<blockquote>
<p>使用goto集中处理错误</p>
</blockquote>
<p>例如重复的错误处理代码，如果后期在这些代码中添加更多的判断，就需要在这些雷同的代码中依次修改，极易造成疏忽和错误。</p>
<pre class=" language-go"><code class="language-go">err <span class="token operator">:=</span> <span class="token function">firstCheckError</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token keyword">goto</span> onExit
<span class="token punctuation">}</span>

err <span class="token operator">=</span> <span class="token function">secondCheckError</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token keyword">goto</span> onExit
<span class="token punctuation">}</span>

fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span>
<span class="token keyword">return</span>

onExit<span class="token punctuation">:</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
    <span class="token function">exitProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h2 id="6、break"><a href="#6、break" class="headerlink" title="6、break"></a>6、break</h2><p>Go语言中 break 语句可以结束 for、switch 和 select 的代码块，另外 break 语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的 for、switch 和 select 的代码块上。</p>
<blockquote>
<p>跳出指定循环</p>
</blockquote>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment" spellcheck="true">// 外层循环的标签</span>
OuterLoop<span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>
            <span class="token keyword">switch</span> j <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>
                fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>
                <span class="token comment" spellcheck="true">// 退出 OuterLoop 对应的循环之外</span>
                <span class="token keyword">break</span> OuterLoop
            <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>
                fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>
                <span class="token comment" spellcheck="true">//退出 OuterLoop 对应的循环之外</span>
                <span class="token keyword">break</span> OuterLoop
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="7、continue"><a href="#7、continue" class="headerlink" title="7、continue"></a>7、continue</h2><p>Go语言中 continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用，在 continue 语句后添加标签时，表示开始标签对应的循环。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
OuterLoop<span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>
            <span class="token keyword">switch</span> j <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>
                fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>
                <span class="token comment" spellcheck="true">//结束当前循环，开启下一次的外层循环</span>
                <span class="token keyword">continue</span> OuterLoop
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h1 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h1><p>函数是组织好的、可重复使用的、用于执行指定任务的代码块，其可以提高应用的模块性和代码的重复利用率。</p>
<p>Go 语言支持普通函数、匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便。</p>
<h2 id="1、函数定义"><a href="#1、函数定义" class="headerlink" title="1、函数定义"></a>1、函数定义</h2><p>函数声明（定义）包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> 函数名<span class="token punctuation">(</span>形式参数列表<span class="token punctuation">)</span><span class="token punctuation">(</span>返回值列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
    函数体
<span class="token punctuation">}</span></code></pre>
<p>形式参数列表描述了函数的参数名以及参数类型，这些参数作为局部变量，其值由参数调用者提供，返回值列表描述了函数返回值的变量名以及类型，如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。</p>
<p>如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。</p>
<h2 id="2、函数的参数"><a href="#2、函数的参数" class="headerlink" title="2、函数的参数"></a>2、函数的参数</h2><blockquote>
<p>类型简写</p>
</blockquote>
<p>函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">intSum</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span></code></pre>
<p>上面的代码中，<code>intSum</code>函数有两个参数，这两个参数的类型均为<code>int</code>，因此可以省略<code>x</code>的类型，因为<code>y</code>后面有类型说明，<code>x</code>参数也是该类型。</p>
<blockquote>
<p>可变参数</p>
</blockquote>
<p>可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加<code>...</code>来标识。</p>
<p>注意：可变参数通常要作为函数的最后一个参数。本质上，函数的可变参数是通过切片来实现的</p>
<h2 id="3、函数的返回值"><a href="#3、函数的返回值" class="headerlink" title="3、函数的返回值"></a>3、函数的返回值</h2><p>Go语言支持多返回值，多返回值能方便地获得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误。</p>
<p>Go语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。</p>
<p>一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。</p>
<blockquote>
<p>同一种类型返回值</p>
</blockquote>
<p>如果返回值是同一种类型，则用括号将多个返回值类型括起来，用逗号分隔每个返回值的类型。</p>
<p>使用 return 语句返回时，值列表的顺序需要与函数声明的返回值类型一致。</p>
<p>纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。</p>
<blockquote>
<p>带有变量名的返回值</p>
</blockquote>
<p>Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型。</p>
<p>命名的返回值变量的默认值为类型的默认值，即数值为 0，字符串为空字符串，布尔为 false、指针为 nil 等。</p>
<p><strong>同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误。</strong></p>
<h2 id="4、调用函数"><a href="#4、调用函数" class="headerlink" title="4、调用函数"></a>4、调用函数</h2><p>函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行，调用前的函数局部变量都会被保存起来不会丢失，被调用的函数运行结束后，恢复到调用函数的下一行继续执行代码，之前的局部变量也能继续访问。</p>
<p>函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。</p>
<p>Go语言的函数调用格式如下：</p>
<pre class=" language-go"><code class="language-go">返回值变量列表 <span class="token operator">=</span> 函数名<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span></code></pre>
<ul>
<li>函数名：需要调用的函数名。</li>
<li>参数列表：参数变量以逗号分隔，尾部无须以分号结尾。</li>
<li>返回值变量列表：多个返回值使用逗号分隔。</li>
</ul>
<p><strong>调用有返回值的函数时，可以不接收其返回值。</strong></p>
<h2 id="5、函数变量"><a href="#5、函数变量" class="headerlink" title="5、函数变量"></a>5、函数变量</h2><blockquote>
<p>把函数作为值保存到变量中</p>
</blockquote>
<p>在Go语言中，函数也是一种类型，可以和其他类型一样保存在变量中，下面的代码定义了一个函数变量 f，并将一个函数名为 fire() 的函数赋给函数变量 f，这样调用函数变量 f 时，实际调用的就是 fire() 函数，代码如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 将变量 f 声明为 func() 类型，此时 f 就被俗称为“回调函数”，此时 f 的值为 nil</span>
    <span class="token keyword">var</span> f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 将 test() 函数作为值，赋给函数变量 f，此时 f 的值为 test() 函数</span>
    f <span class="token operator">=</span> test
    <span class="token comment" spellcheck="true">// 使用函数变量 f 进行函数调用，实际调用的是 test() 函数</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="6、高阶函数"><a href="#6、高阶函数" class="headerlink" title="6、高阶函数"></a>6、高阶函数</h2><p>高阶函数分为函数作为参数和函数作为返回值两部分。</p>
<blockquote>
<p>函数作为参数</p>
</blockquote>
<p>函数可以作为参数：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">calc</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">,</span> op <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">op</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ret2 <span class="token operator">:=</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> add<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ret2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//30</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>函数作为返回值</p>
</blockquote>
<p>函数也可以作为返回值：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">do</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> s <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token string">"+"</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> add<span class="token punctuation">,</span> <span class="token boolean">nil</span>
    <span class="token keyword">case</span> <span class="token string">"-"</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> sub<span class="token punctuation">,</span> <span class="token boolean">nil</span>
    <span class="token keyword">default</span><span class="token punctuation">:</span>
        err <span class="token operator">:=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"无法识别的操作符"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="7、匿名函数"><a href="#7、匿名函数" class="headerlink" title="7、匿名函数"></a>7、匿名函数</h2><p>Go语言支持匿名函数，即在需要使用函数时再定义函数，匿名函数没有函数名只有函数体，函数可以作为一种类型被赋值给函数类型的变量，匿名函数也往往以变量方式传递，这与C语言的回调函数比较类似，不同的是，Go语言支持随时在代码里定义匿名函数。</p>
<p>匿名函数是指不需要定义函数名的一种函数实现方式，由一个不带函数名的函数声明和函数体组成。</p>
<p>匿名函数定义：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">(</span>返回参数列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
    函数体
<span class="token punctuation">}</span></code></pre>
<p>匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 将匿名函数保存到变量</span>
    add <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 通过变量调用匿名函数</span>

    <span class="token comment" spellcheck="true">//自执行函数：匿名函数定义完加()直接执行</span>
    <span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>匿名函数多用于实现回调函数和闭包。</p>
<h2 id="8、闭包（Closure）"><a href="#8、闭包（Closure）" class="headerlink" title="8、闭包（Closure）"></a>8、闭包（Closure）</h2><p>Go语言中闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此，简单的说，<code>函数 + 引用环境 = 闭包</code>。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//1</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//3</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//6</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token builtin">int</span>
    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
        x <span class="token operator">+=</span> y
        <span class="token keyword">return</span> x
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>变量<code>f</code>是一个函数并且它引用了其外部作用域中的<code>x</code>变量，此时<code>f</code>就是一个闭包。 在<code>f</code>的生命周期内，变量<code>x</code>也一直有效。</p>
<blockquote>
<p>在闭包内部修改引用的变量</p>
</blockquote>
<p>闭包对它作用域上部的变量可以进行修改，修改引用的变量会对变量进行实际修改。例：</p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 准备一个字符串</span>
str <span class="token operator">:=</span> <span class="token string">"hello Go"</span>

<span class="token comment" spellcheck="true">// 创建一个匿名函数</span>
foo <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 匿名函数中访问str</span>
    str <span class="token operator">=</span> <span class="token string">"Hello Golang"</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 调用匿名函数</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>在匿名函数中并没有定义 str，str 的定义在匿名函数之前，此时，str 就被引用到了匿名函数中形成了闭包。</p>
<h2 id="9、defer"><a href="#9、defer" class="headerlink" title="9、defer"></a>9、defer</h2><p>Go语言中的<code>defer</code>语句会将其后面跟随的语句进行延迟处理。在<code>defer</code>归属的函数即将返回时，将延迟处理的语句按<code>defer</code>定义的逆序进行执行，也就是说，先被<code>defer</code>的语句最后被执行，最后被<code>defer</code>的语句，最先被执行。</p>
<p>关键字 defer 的用法类似于面向对象编程语言 <a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">Java</a> 和 <a href="http://c.biancheng.net/csharp/" target="_blank" rel="noopener">C#</a> 的 finally 语句块，它一般用于释放某些已分配的资源，典型的例子就是对一个互斥解锁，或者关闭一个文件。</p>
<p>由于<code>defer</code>语句延迟调用的特性，所以<code>defer</code>语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。</p>
<blockquote>
<p>使用延迟执行语句在函数退出时释放资源</p>
</blockquote>
<p>处理业务或逻辑中涉及成对的操作是一件比较烦琐的事情，比如打开和关闭文件、接收请求和回复请求、加锁和解锁等。在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源。</p>
<p>defer 语句正好是在函数退出时执行的语句，所以使用 defer 能非常方便地处理资源释放问题。</p>
<h2 id="10、处理运行时错误"><a href="#10、处理运行时错误" class="headerlink" title="10、处理运行时错误"></a>10、处理运行时错误</h2><p>Go语言的错误处理思想及设计包含以下特征：</p>
<ul>
<li>一个可能造成错误的函数，需要返回值中返回一个错误接口（error），如果调用是成功的，错误接口将返回 nil，否则返回错误。</li>
<li>在函数调用后需要检查错误，如果发生错误，则进行必要的错误处理。</li>
</ul>
<p>Go语言没有类似 <a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">Java</a> 中的异常处理机制，虽然可以使用 defer、panic、recover 模拟，但官方并不主张这样做，Go语言的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的异常付出太多的资源，同时，如果函数使用者觉得错误处理很麻烦而忽略错误，那么程序将在不可预知的时刻崩溃。</p>
<p>Go语言希望开发者将错误处理视为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数，同时，Go语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。</p>
<blockquote>
<p>错误接口定义的格式</p>
</blockquote>
<p>error 是 Go 系统声明的接口类型，代码如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> <span class="token builtin">error</span> <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span></code></pre>
<p>所有符合 Error()string 格式的方法，都能实现错误接口，Error() 方法返回错误的具体描述，使用者可以通过这个字符串知道发生了什么错误。</p>
<blockquote>
<p>自定义错误</p>
</blockquote>
<p>返回错误前，需要定义会产生哪些可能的错误，在Go语言中，使用 errors 包进行错误的定义，格式如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"this is an error"</span><span class="token punctuation">)</span></code></pre>
<p>错误字符串由于相对固定，一般在包作用域声明，应尽量减少在使用时直接使用 errors.New 返回。</p>
<p><strong>1、errors包</strong></p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 创建错误对象</span>
<span class="token keyword">func</span> <span class="token function">New</span><span class="token punctuation">(</span>text <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>errorString<span class="token punctuation">{</span>text<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 错误字符串</span>
<span class="token keyword">type</span> errorString <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    s <span class="token builtin">string</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 返回发生何种错误</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>errorString<span class="token punctuation">)</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> e<span class="token punctuation">.</span>s
<span class="token punctuation">}</span></code></pre>
<p><strong>2、在代码中使用错误定义</strong></p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"errors"</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">// 定义除数为0的错误</span>
<span class="token keyword">var</span> errDivisionByZero <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"division by zero"</span><span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">div</span><span class="token punctuation">(</span>dividend<span class="token punctuation">,</span> divisor <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 判断除数为0的情况并返回</span>
    <span class="token keyword">if</span> divisor <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">,</span> errDivisionByZero
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 正常计算，返回空错误</span>
    <span class="token keyword">return</span> dividend <span class="token operator">/</span> divisor<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">div</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="11、panic"><a href="#11、panic" class="headerlink" title="11、panic"></a>11、panic</h2><p>Go语言的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等，这些运行时错误会引起宕机。</p>
<p>一般而言，当宕机发生时，程序会中断运行，并立即执行在该 goroutine（可以先理解成线程）中被延迟的函数（defer 机制），随后，程序崩溃并输出日志信息，日志信息包括 panic value 和函数调用的堆栈跟踪信息，panic value 通常是某种错误信息。</p>
<p>对于每个 goroutine，日志信息中都会有与之相对的，发生 panic 时的函数调用堆栈跟踪信息，通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据，因此，在我们填写问题报告时，一般会将宕机和日志信息一并记录。</p>
<p>虽然Go语言的 panic 机制类似于其他语言的异常，但 panic 的适用场景有一些不同，由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致。任何崩溃都表明了我们的代码中可能存在漏洞，所以对于大部分漏洞，应该使用Go语言提供的错误机制，而不是 panic。</p>
<p>panic()的声明：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">panic</span><span class="token punctuation">(</span>v <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//panic() 的参数可以是任意类型的。</span></code></pre>
<blockquote>
<p>手动触发宕机</p>
</blockquote>
<p>Go语言可以在程序中手动触发宕机，让程序崩溃，这样开发者可以及时地发现错误，同时减少可能的损失。</p>
<p>Go语言程序在宕机时，会将堆栈和 goroutine 信息输出到控制台，所以宕机也可以方便地知晓发生错误的位置，那么我们要如何触发宕机呢，示例代码如下所示：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>代码运行崩溃，输出如下：</p>
<pre class=" language-bash"><code class="language-bash">panic: <span class="token function">test</span>

goroutine 1 <span class="token punctuation">[</span>running<span class="token punctuation">]</span>:
main.main<span class="token punctuation">(</span><span class="token punctuation">)</span>
        C:/<span class="token punctuation">..</span>./main.go:4 +0x45</code></pre>
<blockquote>
<p>在运行的依赖的必备资源缺失时主动触发宕机</p>
</blockquote>
<p>regexp 是Go语言的正则表达式包，正则表达式需要编译后才能使用，而且编译必须是成功的，表示正则表达式可用。</p>
<p>编译正则表达式函数有两种，具体如下：</p>
<p><strong>func Compile(expr string) (*Regexp, error)</strong></p>
<p>编译正则表达式，发生错误时返回编译错误同时返回 Regexp 为 nil，该函数适用于在编译错误时获得编译错误进行处理，同时继续后续执行的环境。</p>
<p><strong>func MustCompile(str string) *Regexp</strong></p>
<p>当编译正则表达式发生错误时，使用 panic 触发宕机，该函数适用于直接使用正则表达式而无须处理正则表达式错误的情况。</p>
<p>手动宕机进行报错的方式不是一种偷懒的方式，反而能迅速报错，终止程序继续运行，防止更大的错误产生，不过，如果任何错误都使用宕机处理，也不是一种良好的设计习惯，因此应根据需要来决定是否使用宕机进行报错。</p>
<blockquote>
<p>在宕机时触发延迟执行语句</p>
</blockquote>
<p>当 panic() 触发的宕机发生时，panic() 后面的代码将不会被运行，但是在 panic() 函数前面已经运行过的 defer 语句依然会在宕机发生时发生作用。</p>
<h2 id="12、recover"><a href="#12、recover" class="headerlink" title="12、recover"></a>12、recover</h2><p>Recover 是一个Go语言的内建函数，可以让进入宕机流程中的 goroutine 恢复过来，recover 仅在延迟函数 defer 中有效，在正常的执行过程中，调用 recover 会返回 nil 并且没有其他任何效果，如果当前的 goroutine 陷入恐慌，调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。</p>
<p>通常来说，不应该对进入 panic 宕机的程序做任何处理，但有时，需要我们可以从宕机中恢复，至少我们可以在程序崩溃前，做一些操作，举个例子，当 web 服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭，如果不做任何处理，会使得客户端一直处于等待状态，如果 web 服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。</p>
<p>在其他语言里，宕机往往以异常的形式存在，底层抛出异常，上层逻辑通过 try/catch 机制捕获异常，没有被捕获的严重异常会导致宕机，捕获的异常可以被忽略，让代码继续运行。</p>
<p>Go语言没有异常系统，其使用 panic 触发宕机类似于其他语言的抛出异常，recover 的宕机恢复机制就对应其他语言中的 try/catch 机制。</p>
<blockquote>
<p>panic与recover </p>
</blockquote>
<p>panic 和 recover 的组合有如下特性：</p>
<ul>
<li>有 panic 没 recover，程序宕机。</li>
<li>有 panic 也有 recover，程序不会宕机，执行完对应的 defer 后，从宕机点退出当前函数后继续执行。</li>
</ul>
<p>虽然 panic/recover 能模拟其他语言的异常机制，但并不建议在编写普通函数时也经常性使用这种特性。</p>
<p>在 panic 触发的 defer 函数内，可以继续调用 panic，进一步将错误外抛，直到程序整体崩溃。</p>
<p>如果想在捕获错误时设置当前函数的返回值，可以对返回值使用命名返回值方式直接进行设置。</p>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><table>
<thead>
<tr>
<th align="center">内置函数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">close</td>
<td align="center">主要用来关闭channel</td>
</tr>
<tr>
<td align="center">len</td>
<td align="center">用来求长度，比如string、array、slice、map、channel</td>
</tr>
<tr>
<td align="center">new</td>
<td align="center">用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针</td>
</tr>
<tr>
<td align="center">make</td>
<td align="center">用来分配内存，主要用来分配引用类型，比如chan、map、slice</td>
</tr>
<tr>
<td align="center">append</td>
<td align="center">用来追加元素到数组、slice中</td>
</tr>
<tr>
<td align="center">panic和recover</td>
<td align="center">用来做错误处理</td>
</tr>
</tbody></table>
<h1 id="八、结构体"><a href="#八、结构体" class="headerlink" title="八、结构体"></a>八、结构体</h1><h2 id="1、类型别名与自定义类型"><a href="#1、类型别名与自定义类型" class="headerlink" title="1、类型别名与自定义类型"></a>1、类型别名与自定义类型</h2><blockquote>
<p>自定义类型</p>
</blockquote>
<p>在Go语言中有一些基本的数据类型，如<code>string</code>、<code>整型</code>、<code>浮点型</code>、<code>布尔</code>等数据类型， Go语言中可以使用<code>type</code>关键字来定义自定义类型。</p>
<p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//将MyInt定义为int类型</span>
<span class="token keyword">type</span> MyInt <span class="token builtin">int</span></code></pre>
<p>通过<code>type</code>关键字的定义，<code>MyInt</code>就是一种新的类型，它具有<code>int</code>的特性。</p>
<blockquote>
<p>类型别名</p>
</blockquote>
<p>类型别名是<code>Go1.9</code>版本添加的新功能。</p>
<p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> TypeAlias <span class="token operator">=</span> Type</code></pre>
<p>之前见过的<code>rune</code>和<code>byte</code>就是类型别名，它们的定义如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> <span class="token builtin">byte</span> <span class="token operator">=</span> <span class="token builtin">uint8</span>
<span class="token keyword">type</span> <span class="token builtin">rune</span> <span class="token operator">=</span> <span class="token builtin">int32</span></code></pre>
<h2 id="2、结构体的定义"><a href="#2、结构体的定义" class="headerlink" title="2、结构体的定义"></a>2、结构体的定义</h2><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p>
<p>Go 语言通过用自定义的方式形成新的类型，结构体是类型中带有成员的复合类型。Go 语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性。</p>
<p>Go 语言中的类型可以被实例化，使用<code>new</code>或<code>&amp;</code>构造的类型实例的类型是类型的指针。</p>
<p>结构体成员是由一系列的成员变量构成，这些成员变量也被称为“字段”。字段有以下特性：</p>
<ul>
<li>字段拥有自己的类型和值。</li>
<li>字段名必须唯一。</li>
<li>字段的类型也可以是结构体，甚至是字段所在结构体的类型。</li>
</ul>
<p>使用关键字 <strong>type</strong> 可以将各种基本类型定义为自定义类型，基本类型包括整型、字符串、布尔等。结构体是一种复合的基本类型，通过 type 定义为自定义类型后，使结构体更便于使用。</p>
<p>结构体的定义格式如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> 类型名 <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    字段<span class="token number">1</span> 字段<span class="token number">1</span>类型
    字段<span class="token number">2</span> 字段<span class="token number">2</span>类型
    …
<span class="token punctuation">}</span></code></pre>
<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>struct{}：表示结构体类型，<code>type 类型名 struct{}</code>可以理解为将 struct{} 结构体定义为类型名的类型。</li>
<li>字段1、字段2……：表示结构体字段名，结构体中的字段名必须唯一。</li>
<li>字段1类型、字段2类型……：表示结构体各个字段的类型。</li>
</ul>
<p>构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存。</p>
<h2 id="3、结构体实例化"><a href="#3、结构体实例化" class="headerlink" title="3、结构体实例化"></a>3、结构体实例化</h2><p>结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存，因此必须在定义结构体并实例化后才能使用结构体的字段。</p>
<p>实例化就是根据结构体定义的格式创建一份与格式一致的内存区域，结构体实例与实例间的内存是完全独立的。</p>
<p>Go语言可以通过多种方式实例化结构体，根据实际需要可以选用不同的写法。</p>
<h3 id="基本实例化"><a href="#基本实例化" class="headerlink" title="基本实例化"></a>基本实例化</h3><p>结构体本身是一种类型，可以像整型、字符串等类型一样，以 var 的方式声明结构体即可完成实例化。</p>
<p>基本实例化格式如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> 结构体实例 结构体类型</code></pre>
<p>用结构体表示的点结构（Point）的实例化过程请参见下面的代码：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> Point <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    X <span class="token builtin">int</span>
    Y <span class="token builtin">int</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> p Point
p<span class="token punctuation">.</span>X <span class="token operator">=</span> <span class="token number">10</span>
p<span class="token punctuation">.</span>Y <span class="token operator">=</span> <span class="token number">20</span></code></pre>
<p>在例子中，使用<code>.</code>来访问结构体的成员变量，如<code>p.X</code>和<code>p.Y</code>等，结构体成员变量的赋值方法与普通变量一致。</p>
<h3 id="匿名结构体"><a href="#匿名结构体" class="headerlink" title="匿名结构体"></a>匿名结构体</h3><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> user <span class="token keyword">struct</span><span class="token punctuation">{</span>Name <span class="token builtin">string</span><span class="token punctuation">;</span> Age <span class="token builtin">int</span><span class="token punctuation">}</span>
    user<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">"pprof.cn"</span>
    user<span class="token punctuation">.</span>Age <span class="token operator">=</span> <span class="token number">18</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v\n"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="创建指针类型结构体"><a href="#创建指针类型结构体" class="headerlink" title="创建指针类型结构体"></a>创建指针类型结构体</h3><p>Go语言中，还可以使用 new 关键字对类型（包括结构体、整型、浮点数、字符串等）进行实例化，结构体在实例化后会形成指针类型的结构体。</p>
<pre class=" language-go"><code class="language-go">结构体实例 <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>结构体类型<span class="token punctuation">)</span></code></pre>
<p>也可以像访问普通结构体一样使用<code>.</code>来访问结构体指针的成员。</p>
<h3 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a>取结构体的地址实例化</h3><p>在Go语言中，对结构体进行<code>&amp;</code>取地址操作时，视为对该类型进行一次 new 的实例化操作，取地址格式如下：</p>
<pre class=" language-go"><code class="language-go">结构体实例 <span class="token operator">:=</span> <span class="token operator">&amp;</span>结构体类型<span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>
<h2 id="4、初始化结构体"><a href="#4、初始化结构体" class="headerlink" title="4、初始化结构体"></a>4、初始化结构体</h2><p>没有初始化的结构体，其成员变量都是对应其类型的零值。</p>
<h3 id="使用键值对初始化结构体"><a href="#使用键值对初始化结构体" class="headerlink" title="使用键值对初始化结构体"></a>使用键值对初始化结构体</h3><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p>
<p>键值对初始化结构体的书写格式：</p>
<pre class=" language-go"><code class="language-go">结构体实例 <span class="token operator">:=</span> 结构体类型<span class="token punctuation">{</span>
    字段<span class="token number">1</span><span class="token punctuation">:</span> 字段<span class="token number">1</span>的值<span class="token punctuation">,</span>
    字段<span class="token number">2</span><span class="token punctuation">:</span> 字段<span class="token number">2</span>的值<span class="token punctuation">,</span>
    …
<span class="token punctuation">}</span></code></pre>
<p>键值之间以<code>:</code>分隔，键值对之间以<code>,</code>分隔。</p>
<h3 id="使用多个值的列表初始化结构体"><a href="#使用多个值的列表初始化结构体" class="headerlink" title="使用多个值的列表初始化结构体"></a>使用多个值的列表初始化结构体</h3><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p>
<pre class=" language-go"><code class="language-go">结构体实例 <span class="token operator">:=</span> 结构体类型<span class="token punctuation">{</span>
    字段<span class="token number">1</span>的值<span class="token punctuation">,</span>
    字段<span class="token number">2</span>的值<span class="token punctuation">,</span>
    …
<span class="token punctuation">}</span></code></pre>
<ul>
<li>必须初始化结构体的所有字段。</li>
<li>每一个初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li>
<li>键值对与值列表的初始化形式不能混用。</li>
</ul>
<h3 id="初始化匿名结构体"><a href="#初始化匿名结构体" class="headerlink" title="初始化匿名结构体"></a>初始化匿名结构体</h3><p>匿名结构体没有类型名称，无须通过 type 关键字定义就可以直接使用。</p>
<p>匿名结构体的初始化写法由结构体定义和键值对初始化两部分组成，结构体定义时没有结构体类型名，只有字段和类型定义，键值对初始化部分由可选的多个键值对组成，如下格式所示：</p>
<pre class=" language-go"><code class="language-go">ins <span class="token operator">:=</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 匿名结构体字段定义</span>
    字段<span class="token number">1</span> 字段类型<span class="token number">1</span>
    字段<span class="token number">2</span> 字段类型<span class="token number">2</span>
    …
<span class="token punctuation">}</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 字段值初始化</span>
    初始化字段<span class="token number">1</span><span class="token punctuation">:</span> 字段<span class="token number">1</span>的值<span class="token punctuation">,</span>
    初始化字段<span class="token number">2</span><span class="token punctuation">:</span> 字段<span class="token number">2</span>的值<span class="token punctuation">,</span>
    …
<span class="token punctuation">}</span></code></pre>
<p>键值对初始化部分是可选的，不初始化成员时，匿名结构体的格式变为：</p>
<pre class=" language-go"><code class="language-go">ins <span class="token operator">:=</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    字段<span class="token number">1</span> 字段类型<span class="token number">1</span>
    字段<span class="token number">2</span> 字段类型<span class="token number">2</span>
    …
<span class="token punctuation">}</span></code></pre>
<h2 id="5、构造函数"><a href="#5、构造函数" class="headerlink" title="5、构造函数"></a>5、构造函数</h2><p>Go语言的类型或结构体没有构造函数的功能，但是我们可以使用结构体初始化的过程来模拟实现构造函数。</p>
<p>例如，实现一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">newPerson</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> city <span class="token builtin">string</span><span class="token punctuation">,</span> age <span class="token builtin">int8</span><span class="token punctuation">)</span> <span class="token operator">*</span>person <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>person<span class="token punctuation">{</span>
        name<span class="token punctuation">:</span> name<span class="token punctuation">,</span>
        city<span class="token punctuation">:</span> city<span class="token punctuation">,</span>
        age<span class="token punctuation">:</span>  age<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>调用构造函数：</p>
<pre class=" language-go"><code class="language-go">p <span class="token operator">:=</span> <span class="token function">newPerson</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token string">"test"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v\n"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span></code></pre>
<h2 id="6、方法和接收者"><a href="#6、方法和接收者" class="headerlink" title="6、方法和接收者"></a>6、方法和接收者</h2><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。</p>
<p>方法的定义格式如下：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>接收者变量 接收者类型<span class="token punctuation">)</span> 方法名<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span> <span class="token punctuation">(</span>返回参数<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    函数体
<span class="token punctuation">}</span></code></pre>
<ul>
<li>接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是<code>self</code>、<code>this</code>之类的命名。例如，<code>Person</code>类型的接收者变量应该命名为 <code>p</code>，<code>Connector</code>类型的接收者变量应该命名为<code>c</code>等。</li>
<li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：具体格式与函数定义相同</li>
</ul>
<p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p>
<blockquote>
<p>指针类型的接收者</p>
</blockquote>
<p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。</p>
<p>例如为Person添加一个SetAge方法，来修改实例变量的年龄。</p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Person 结构体</span>
<span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    name <span class="token builtin">string</span>
    age  <span class="token builtin">int8</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// SetAge 设置p的年龄</span>
<span class="token comment" spellcheck="true">// 使用指针接收者</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">SetAge</span><span class="token punctuation">(</span>newAge <span class="token builtin">int8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p<span class="token punctuation">.</span>age <span class="token operator">=</span> newAge
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p1 <span class="token operator">:=</span> <span class="token function">NewPerson</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 18</span>
    p1<span class="token punctuation">.</span><span class="token function">SetAge</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 20</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>什么时候使用指针类型的接收者</strong></p>
<ul>
<li>需要修改接收者中的值</li>
<li>接收者是拷贝代价比较大的大对象</li>
<li>保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</li>
</ul>
<blockquote>
<p>值类型的接收者</p>
</blockquote>
<p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p>
<h2 id="7、任意类型添加方法"><a href="#7、任意类型添加方法" class="headerlink" title="7、任意类型添加方法"></a>7、任意类型添加方法</h2><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 </p>
<p>例如，基于内置的int类型使用type关键字可以定义新的自定义类型，然后为自定义类型添加方法。</p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//MyInt 将int定义为自定义MyInt类型</span>
<span class="token keyword">type</span> MyInt <span class="token builtin">int</span>

<span class="token comment" spellcheck="true">//SayHello 为MyInt添加一个SayHello的方法</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>m MyInt<span class="token punctuation">)</span> <span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello, 我是一个int。"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> m1 MyInt
    m1<span class="token punctuation">.</span><span class="token function">SayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//Hello, 我是一个int。</span>
    m1 <span class="token operator">=</span> <span class="token number">100</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v  %T\n"</span><span class="token punctuation">,</span> m1<span class="token punctuation">,</span> m1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//100  main.MyInt</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</strong></p>
<h2 id="8、结构体的匿名字段"><a href="#8、结构体的匿名字段" class="headerlink" title="8、结构体的匿名字段"></a>8、结构体的匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Person 结构体Person类型</span>
<span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token builtin">string</span>
    <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p1 <span class="token operator">:=</span> Person<span class="token punctuation">{</span>
        <span class="token string">"test"</span><span class="token punctuation">,</span>
        <span class="token number">18</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v\n"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//main.Person{string:"test", int:18}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token builtin">string</span><span class="token punctuation">,</span> p1<span class="token punctuation">.</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//test 18</span>
<span class="token punctuation">}</span></code></pre>
<p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p>
<h2 id="9、嵌套结构体"><a href="#9、嵌套结构体" class="headerlink" title="9、嵌套结构体"></a>9、嵌套结构体</h2><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">type</span> A <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    ax<span class="token punctuation">,</span> ay <span class="token builtin">int</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> B <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    A
    bx<span class="token punctuation">,</span> by <span class="token builtin">float32</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b <span class="token operator">:=</span> B<span class="token punctuation">{</span>A<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>ax<span class="token punctuation">,</span> b<span class="token punctuation">.</span>ay<span class="token punctuation">,</span> b<span class="token punctuation">.</span>bx<span class="token punctuation">,</span> b<span class="token punctuation">.</span>by<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>A<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>结构体嵌套有如下特性：</p>
<ul>
<li><p>内嵌的结构体可以直接访问其成员变量</p>
<p>嵌入结构体的成员，可以通过外部结构体的实例直接访问。如果结构体有多层嵌入结构体，结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。例如，ins.a.b.c的访问可以简化为ins.c。</p>
</li>
<li><p>内嵌结构体的字段名是它的类型名</p>
<p>内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名。</p>
</li>
</ul>
<p>一个结构体只能嵌入一个同类型的成员，无须担心结构体重名和错误赋值的情况，编译器在发现可能的赋值歧义时会报错。</p>
<h3 id="嵌套匿名字段"><a href="#嵌套匿名字段" class="headerlink" title="嵌套匿名字段"></a>嵌套匿名字段</h3><p>结构体可以包含一个或多个匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型也就是字段的名字。匿名字段本身可以是一个结构体类型，即结构体可以包含内嵌结构体。</p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Address 地址结构体</span>
<span class="token keyword">type</span> Address <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Province <span class="token builtin">string</span>
    City     <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//User 用户结构体</span>
<span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Name    <span class="token builtin">string</span>
    Gender  <span class="token builtin">string</span>
    Address <span class="token comment" spellcheck="true">//匿名结构体</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> user2 User
    user2<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">"test"</span>
    user2<span class="token punctuation">.</span>Gender <span class="token operator">=</span> <span class="token string">"男"</span>
    user2<span class="token punctuation">.</span>Address<span class="token punctuation">.</span>Province <span class="token operator">=</span> <span class="token string">"贵州"</span>    <span class="token comment" spellcheck="true">//通过匿名结构体.字段名访问</span>
    user2<span class="token punctuation">.</span>City <span class="token operator">=</span> <span class="token string">"贵阳"</span>                <span class="token comment" spellcheck="true">//直接访问匿名结构体的字段名</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"user2=%#v\n"</span><span class="token punctuation">,</span> user2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//user2=main.User{Name:"test", Gender:"男", Address:main.Address{Province:"贵州", City:"贵阳"}}</span>
<span class="token punctuation">}</span></code></pre>
<p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p>
<h3 id="嵌套结构体的字段名冲突"><a href="#嵌套结构体的字段名冲突" class="headerlink" title="嵌套结构体的字段名冲突"></a>嵌套结构体的字段名冲突</h3><p>嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p>
<h2 id="10、结构体的继承"><a href="#10、结构体的继承" class="headerlink" title="10、结构体的继承"></a>10、结构体的继承</h2><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Animal 动物</span>
<span class="token keyword">type</span> Animal <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    name <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>Animal<span class="token punctuation">)</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s会动！\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//Dog 狗</span>
<span class="token keyword">type</span> Dog <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Feet    <span class="token builtin">int8</span>
    <span class="token operator">*</span>Animal <span class="token comment" spellcheck="true">//通过嵌套匿名结构体实现继承</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>d <span class="token operator">*</span>Dog<span class="token punctuation">)</span> <span class="token function">wang</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s会汪汪汪~\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    d1 <span class="token operator">:=</span> <span class="token operator">&amp;</span>Dog<span class="token punctuation">{</span>
        Feet<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
        Animal<span class="token punctuation">:</span> <span class="token operator">&amp;</span>Animal<span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//注意嵌套的是结构体指针</span>
            name<span class="token punctuation">:</span> <span class="token string">"小黑"</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    d1<span class="token punctuation">.</span><span class="token function">wang</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//小黑会汪汪汪~</span>
    d1<span class="token punctuation">.</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//小黑会动！</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="11、结构体字段的可见性"><a href="#11、结构体字段的可见性" class="headerlink" title="11、结构体字段的可见性"></a>11、结构体字段的可见性</h2><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p>
<h2 id="12、结构体与JSON序列化"><a href="#12、结构体与JSON序列化" class="headerlink" title="12、结构体与JSON序列化"></a>12、结构体与JSON序列化</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号””包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。</p>
<pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//Student 学生</span>
<span class="token keyword">type</span> Student <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    ID     <span class="token builtin">int</span>
    Gender <span class="token builtin">string</span>
    Name   <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//Class 班级</span>
<span class="token keyword">type</span> Class <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    Title    <span class="token builtin">string</span>
    Students <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Student
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c <span class="token operator">:=</span> <span class="token operator">&amp;</span>Class<span class="token punctuation">{</span>
        Title<span class="token punctuation">:</span>    <span class="token string">"101"</span><span class="token punctuation">,</span>
        Students<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>Student<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
        stu <span class="token operator">:=</span> <span class="token operator">&amp;</span>Student<span class="token punctuation">{</span>
            Name<span class="token punctuation">:</span>   fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"stu%02d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span>
            Gender<span class="token punctuation">:</span> <span class="token string">"男"</span><span class="token punctuation">,</span>
            ID<span class="token punctuation">:</span>     i<span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
        c<span class="token punctuation">.</span>Students <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Students<span class="token punctuation">,</span> stu<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//JSON序列化：结构体-->JSON格式的字符串</span>
    data<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"json marshal failed"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"json:%s\n"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//JSON反序列化：JSON格式的字符串-->结构体</span>
    str <span class="token operator">:=</span> <span class="token string">`{"Title":"101","Students":[{"ID":0,"Gender":"男","Name":"stu00"},{"ID":1,"Gender":"男","Name":"stu01"},{"ID":2,"Gender":"男","Name":"stu02"},{"ID":3,"Gender":"男","Name":"stu03"},{"ID":4,"Gender":"男","Name":"stu04"},{"ID":5,"Gender":"男","Name":"stu05"},{"ID":6,"Gender":"男","Name":"stu06"},{"ID":7,"Gender":"男","Name":"stu07"},{"ID":8,"Gender":"男","Name":"stu08"},{"ID":9,"Gender":"男","Name":"stu09"}]}`</span>
    c1 <span class="token operator">:=</span> <span class="token operator">&amp;</span>Class<span class="token punctuation">{</span><span class="token punctuation">}</span>
    err <span class="token operator">=</span> json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> c1<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"json unmarshal failed!"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#v\n"</span><span class="token punctuation">,</span> c1<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="13、结构体标签（Tag）"><a href="#13、结构体标签（Tag）" class="headerlink" title="13、结构体标签（Tag）"></a>13、结构体标签（Tag）</h2><p><code>Tag</code>是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 <code>Tag</code>在结构体字段的后方定义，由一对<strong>反引号</strong>包裹起来，具体的格式如下：</p>
<pre class=" language-bash"><code class="language-bash">`key1:<span class="token string">"value1"</span> key2:<span class="token string">"value2"</span>`</code></pre>
<p>结构体tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p>
<p><strong>注：</strong> 为结构体编写<code>Tag</code>时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p>
<p>例如为<code>Student</code>结构体的每个字段定义json序列化时使用的Tag：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"encoding/json"</span>
    <span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">//Student 学生</span>
<span class="token keyword">type</span> Student <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    ID     <span class="token builtin">int</span>    <span class="token string">`json:"id"`</span> <span class="token comment" spellcheck="true">//通过指定tag实现json序列化该字段时的key</span>
    Gender <span class="token builtin">string</span> <span class="token comment" spellcheck="true">//json序列化是默认使用字段名作为key</span>
    name   <span class="token builtin">string</span> <span class="token comment" spellcheck="true">//私有不能被json包访问</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    s1 <span class="token operator">:=</span> Student<span class="token punctuation">{</span>
        ID<span class="token punctuation">:</span>     <span class="token number">1</span><span class="token punctuation">,</span>
        Gender<span class="token punctuation">:</span> <span class="token string">"男"</span><span class="token punctuation">,</span>
        name<span class="token punctuation">:</span>   <span class="token string">"张三"</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    data<span class="token punctuation">,</span> err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Marshal</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"json marshal failed!"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"json str:%s\n"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//json str:{"id":1,"Gender":"男"}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="14、垃圾回收和SetFinalizer"><a href="#14、垃圾回收和SetFinalizer" class="headerlink" title="14、垃圾回收和SetFinalizer"></a>14、垃圾回收和SetFinalizer</h2><p>Go语言自带垃圾回收机制（GC）。GC 通过独立的进程执行，它会搜索不再使用的变量，并将其释放。需要注意的是，GC 在运行时会占用机器资源。</p>
<p>GC 是自动进行的，如果要手动进行 GC，可以使用 runtime.GC() 函数，显式的执行 GC。显式的进行 GC 只在某些特殊的情况下才有用，比如当内存资源不足时调用 runtime.GC() ，这样会立即释放一大片内存，但是会造成程序短时间的性能下降。</p>
<p>finalizer（终止器）是与对象关联的一个函数，通过 runtime.SetFinalizer 来设置，如果某个对象定义了 finalizer，当它被 GC 时候，这个 finalizer 就会被调用，以完成一些特定的任务，例如发信号或者写日志等。</p>
<p>在Go语言中 SetFinalizer 函数是这样定义的：</p>
<pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">SetFinalizer</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> f <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<ul>
<li>参数 x 必须是一个指向通过 new 申请的对象的指针，或者通过对复合字面值取址得到的指针。</li>
<li>参数 f 必须是一个函数，它接受单个可以直接用 x 类型值赋值的参数，也可以有任意个被忽略的返回值。</li>
</ul>
<p>SetFinalizer 函数可以将 x 的终止器设置为 f，当垃圾收集器发现 x 不能再直接或间接访问时，它会清理 x 并调用 f(x)。</p>
<p>另外，x 的终止器会在 x 不能直接或间接访问后的任意时间被调用执行，不保证终止器会在程序退出前执行，因此一般终止器只用于在长期运行的程序中释放关联到某对象的非内存资源。例如，当一个程序丢弃一个 os.File 对象时没有调用其 Close 方法，该 os.File 对象可以使用终止器去关闭对应的操作系统文件描述符。</p>
<p>终止器会按依赖顺序执行：如果 A 指向 B，两者都有终止器，且 A 和 B 没有其它关联，那么只有 A 的终止器执行完成，并且 A 被释放后，B 的终止器才可以执行。</p>
<p>如果 *x 的大小为 0 字节，也不保证终止器会执行。</p>
<p>此外，我们也可以使用<code>SetFinalizer(x, nil)</code>来清理绑定到 x 上的终止器。</p>
<p>终止器只有在对象被 GC 时，才会被执行。其他情况下，都不会被执行，即使程序正常结束或者发生错误。</p>
<h1 id="九、接口"><a href="#九、接口" class="headerlink" title="九、接口"></a>九、接口</h1><p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p>
<p>在Go语言中接口（interface）是一种类型，一种抽象的类型。</p>
<p><code>interface</code>是一组<code>method</code>的集合，是<code>duck-type programming</code>的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。不关心属性（数据），只关心行为（方法）</p>
<h2 id="1、接口声明"><a href="#1、接口声明" class="headerlink" title="1、接口声明"></a>1、接口声明</h2><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> 接口类型名 <span class="token keyword">interface</span><span class="token punctuation">{</span>
    方法名<span class="token function">1</span><span class="token punctuation">(</span> 参数列表<span class="token number">1</span> <span class="token punctuation">)</span> 返回值列表<span class="token number">1</span>
    方法名<span class="token function">2</span><span class="token punctuation">(</span> 参数列表<span class="token number">2</span> <span class="token punctuation">)</span> 返回值列表<span class="token number">2</span>
    …
<span class="token punctuation">}</span></code></pre>
<ul>
<li>接口类型名：使用<code>type</code>将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有字符串功能的接口叫<code>Stringer</code>等。接口名最好要能突出该接口的类型含义。</li>
<li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li>
</ul>
<h2 id="2、实现接口的条件"><a href="#2、实现接口的条件" class="headerlink" title="2、实现接口的条件"></a>2、实现接口的条件</h2><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个需要实现的方法列表。</p>
<ul>
<li>接口的方法与实现接口的类型方法格式一致。</li>
<li>接口中所有方法均被实现。</li>
</ul>
<h2 id="3、类型与接口的关系"><a href="#3、类型与接口的关系" class="headerlink" title="3、类型与接口的关系"></a>3、类型与接口的关系</h2><blockquote>
<p>一个类型实现多个接口</p>
</blockquote>
<p>个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。</p>
<blockquote>
<p>多个类型实现同一接口</p>
</blockquote>
<p>一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。也就是说，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。</p>
<h2 id="4、空接口"><a href="#4、空接口" class="headerlink" title="4、空接口"></a>4、空接口</h2><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p>
<p>空接口类型的变量可以存储任意类型的变量。</p>

            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Go/">
                                    <span class="chip bg-color">Go</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    /* #vcomments .vwrap {
        box-sizing: border-box;
        padding: 0 0 44px;
        background-color: #F0FFF0;
    }
    #vcomments .vwrap .vheader{width: 80%;bottom:0;position: absolute;background: #F0FFF0;}

    #vcomments .vinput{padding:10px 15px; text-align: center;}

    #vcomments .vwrap .vheader .vinput{border-bottom:0px}

    #vcomments .vwrap .vedit .vctrl{margin-top:-44px;right:0;position:absolute;margin-right:-3px;}

    #vcomments  .vwrap .vrow{position:absolute;right:0;bottom:0;width:20%;padding-top:0px;}

    #vcomments  .vrow {font-size: 0;padding: 0px 0;}

    #vcomments  .vicon {margin-right: 15px;}

    #vcomments  .vrow .vcol.vcol-30{display: none}

    #vcomments  .vedit .vctrl span.vpreview-btn{display: none}

    #vcomments  .vrow .vcol.vcol-70{width: 100%;}

    #vcomments  .vsubmit.vbtn{border-radius: 0;padding: 0;color: #fff;line-height: 44px;width:100%;border: none;background:#00ecbc;}

    #vcomments  .vcards .vcard .vh .vhead .vsys{background: #F0FFF0;}

    #vcomments  .vcards .vcard .vh .vmeta .vat{font-size: 12px;display: block;margin-left: 15px;float: right;color: #fff;background-color: #00ecbc;line-height: 20px;padding: 0 6px;border-radius: 3px;}

    @media screen and (max-width: 520px){
    #vcomments  .vwrap .vheader .vinput{width: 33.33%;padding:10px 5px;}  
    } */

    #vcomments input[type=text],

    #vcomments input[type=email],

    #vcomments input[type=url],

    #vcomments textarea {
        box-sizing: border-box;
    }
    #vcomments .vwrap p {
        height: 20px;
        width: 20px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }
    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    /* 修复评论第一行位置错位 */
    .v .vlist .vcard {
    padding-top: 2.5em !important ;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        admin_email: '2292807998@qq.com',
        appId: 'vDtNtruYzjCbFJbWyeQ8Bybw-gzGzoHsz',
        appKey: 'TJv4iKCEAYMHDhy8V8IvAJGF',
        path: window.location.pathname,
        comment_count: true,
        notify: 'false' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: 'retro',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'ヾﾉ≧∀≦)o在这里可以留言评论喔！',

    });
    $(document).ready(function(){
        $("#vcomments").on('click', 'span.vat',function(){
            $(this).parent('div.vmeta').next("div.vcontent").after($("div.vwrap"));
            $('textarea#veditor').focus();
        })
    })
</script>
<!-- <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
<script type="text/javascript">
    jinrishici.load(function(result) {
        var jrsc_plac =  result.data.content + "\n「" + result.data.origin.title + "」" + result.data.origin.dynasty + " · " + result.data.origin.author
        document.getElementById("veditor").setAttribute("placeholder",jrsc_plac);
    });
</script> -->

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/archives/df0861b3/">
                    <div class="card-image">
                        
                        <img src="https://cdn.jsdelivr.net/gh/lskjwp/image@master/imageCover/PE制作.png" class="responsive-img" alt="PE制作">
                        
                        <span class="card-title">PE制作</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            视频推荐：打造自己的PE和万能启动U盘
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-09-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/PE/" class="post-category">
                                    PE
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/PE/">
                        <span class="chip bg-color">PE</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/archives/4b0e1d36/">
                    <div class="card-image">
                        
                        <img src="https://cdn.jsdelivr.net/gh/lskjwp/image/imageCover/Oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.jpg" class="responsive-img" alt="Oracle数据库学习笔记">
                        
                        <span class="card-title">Oracle数据库学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            学习视频链接：B站 动力节点
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-05-27
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Oracle/" class="post-category">
                                    Oracle
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Oracle/">
                        <span class="chip bg-color">Oracle</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" >
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

    <div id="floating-toc-btn" class="hide-on-med-and-down" >
        <a class="btn-floating btn-large waves-effect waves-light" title="展开/关闭TOC">
            <i class="fas fa-list-ul" style="zoom: 0.88;"></i>
        </a>
    </div>
<!-- <div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div> -->


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="6668004913"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">勇也很努力</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">317.4k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv" style="display: none;">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv" style="display:none">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "7";
                    var startDate = "1";
                    var startHour = "14";
                    var startMinute = "24";
                    var startSecond = "48";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:2292807998@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2292807998" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2292807998" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>
<script>
    /*
    修改不蒜子初始化计数
    */
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);  // 50ms周期检测函数
        var pvcountOffset = 3000;  // 初始化首次数据
        var uvcountOffset = 1100;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int); // 停止检测
            }
        }
    });
</script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!" title="返回顶部">
        <i class="fas fa-arrow-up" style="zoom: 0.88;"></i>
    </a>
</div>

    <!-- <script src="/js/fireworks.js"></script> -->
    <!-- <script src="/js/cursor.js"></script> -->
    <!-- <script src="/js/click_show_text.js"></script> -->
    <!-- <script src="/js/snow.js"></script> -->


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    
    <script>
        (function (i, s, o, g, r, a, m) {
            i["DaoVoiceObject"] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o), m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            a.charset = "utf-8";
            m.parentNode.insertBefore(a, m)
        })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
            "//widget.daovoice.io/widget/6984b559.js", "daovoice")
        daovoice('init', {
            app_id: "f9383031"
        });
        daovoice('update');
    </script>
    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

    <script type="text/javascript">
        var OriginTitile=document.title,st;
        document.addEventListener("visibilitychange",function(){
            document.hidden?(document.title="ヽ(●-`Д´-)ノ你要玩捉迷藏嘛",clearTimeout(st)):(document.title="(Ő∀Ő3)ノ好哦！",st=setTimeout(function(){document.title=OriginTitile},3e3))
        })
    </script>

    <!--夜晚模式-->
    <script>
        if (localStorage.getItem('dark') === '1') {
        document.body.classList.add('dark');
        }
        else if (new Date().getHours() >= 22 || new Date().getHours() < 7) {
        document.body.classList.add('dark');
        } 
        else if (matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
        }
    </script>

    <!--全屏-->
    <script src="/js/fullscreen.js" type="module"></script>
    <a onclick="switchNightMode()" id="sma">
        <i class="fa fa-moon-o" id="nightMode" aria-hidden="true"></i>
    </a><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>

</html>
